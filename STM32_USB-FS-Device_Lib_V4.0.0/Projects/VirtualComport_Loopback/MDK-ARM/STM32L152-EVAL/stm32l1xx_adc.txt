; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_adc.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_adc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;563      */
;;;564    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  6842              LDR      r2,[r0,#4]
;;;565    {
;;;566      uint32_t tmpreg = 0;
;;;567    
;;;568      /* Check the parameters */
;;;569      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;570      assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;571    
;;;572      /* Get the old register value */
;;;573      tmpreg = ADCx->CR1;
;;;574      /* Clear AWDEN, JAWDEN and AWDSGL bits */   
;;;575      tmpreg &= CR1_AWDMODE_RESET;
000002  4b02              LDR      r3,|L1.12|
000004  401a              ANDS     r2,r2,r3
;;;576      /* Set the analog watchdog enable mode */
;;;577      tmpreg |= ADC_AnalogWatchdog;
000006  430a              ORRS     r2,r2,r1
;;;578      /* Store the new register value */
;;;579      ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;580    }
00000a  4770              BX       lr
;;;581    
                          ENDP

                  |L1.12|
                          DCD      0xff3ffdff

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;653      */
;;;654    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  6842              LDR      r2,[r0,#4]
;;;655    {
;;;656      uint32_t tmpreg = 0;
;;;657    
;;;658      /* Check the parameters */
;;;659      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;660      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;661    
;;;662      /* Get the old register value */
;;;663      tmpreg = ADCx->CR1;
;;;664      /* Clear the Analog watchdog channel select bits */
;;;665      tmpreg &= CR1_AWDCH_RESET;
000002  f022021f          BIC      r2,r2,#0x1f
;;;666      /* Set the Analog watchdog channel */
;;;667      tmpreg |= ADC_Channel;
000006  430a              ORRS     r2,r2,r1
;;;668      /* Store the new register value */
;;;669      ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;670    }
00000a  4770              BX       lr
;;;671    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;590      */
;;;591    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  6281              STR      r1,[r0,#0x28]
;;;592                                            uint16_t LowThreshold)
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;596      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;597      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;598    
;;;599      /* Set the ADCx high threshold */
;;;600      ADCx->HTR = HighThreshold;
;;;601      /* Set the ADCx low threshold */
;;;602      ADCx->LTR = LowThreshold;
000002  62c2              STR      r2,[r0,#0x2c]
;;;603    }
000004  4770              BX       lr
;;;604    
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;1577     */
;;;1578   void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1579   {
;;;1580     /* Check the parameters */
;;;1581     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1582     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1583   
;;;1584     if (NewState != DISABLE)
;;;1585     {
;;;1586       /* Enable the selected ADC automatic injected group conversion */
;;;1587       ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
;;;1588     }
;;;1589     else
;;;1590     {
;;;1591       /* Disable the selected ADC automatic injected group conversion */
;;;1592       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L4.12|
000006  f4416180          ORR      r1,r1,#0x400          ;1587
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L4.16|
000010  6041              STR      r1,[r0,#4]            ;1587
;;;1593     }
;;;1594   }
000012  4770              BX       lr
;;;1595   
                          ENDP


                          AREA ||i.ADC_BankSelection||, CODE, READONLY, ALIGN=1

                  ADC_BankSelection PROC
;;;381      */
;;;382    void ADC_BankSelection(ADC_TypeDef* ADCx, uint8_t ADC_Bank)
000000  2900              CMP      r1,#0
;;;383    {
;;;384      /* Check the parameters */
;;;385      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;386      assert_param(IS_ADC_BANK(ADC_Bank));
;;;387    
;;;388      if (ADC_Bank != ADC_Bank_A)
;;;389      {
;;;390        /* Set the ADC_CFG bit to select the ADC Bank B channels */
;;;391        ADCx->CR2 |= (uint32_t)ADC_CR2_CFG;
;;;392      }
;;;393      else
;;;394      {
;;;395        /* Reset the ADC_CFG bit to select the ADC Bank A channels */
;;;396        ADCx->CR2 &= (uint32_t)(~ADC_CR2_CFG);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L5.12|
000006  f0410104          ORR      r1,r1,#4              ;391
00000a  e001              B        |L5.16|
                  |L5.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L5.16|
000010  6081              STR      r1,[r0,#8]            ;391
;;;397      }
;;;398    }
000012  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;1815     */
;;;1816   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
000000  43c9              MVNS     r1,r1
;;;1817   {
;;;1818     /* Check the parameters */
;;;1819     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1820     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1821   
;;;1822     /* Clear the selected ADC flags */
;;;1823     ADCx->SR = ~(uint32_t)ADC_FLAG;
000002  6001              STR      r1,[r0,#0]
;;;1824   }
000004  4770              BX       lr
;;;1825   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;1877     */
;;;1878   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  ea6f2111          MVN      r1,r1,LSR #8
;;;1879   {
;;;1880     uint8_t itmask = 0;
;;;1881   
;;;1882     /* Check the parameters */
;;;1883     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1884     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1885   
;;;1886     /* Get the ADC IT index */
;;;1887     itmask = (uint8_t)(ADC_IT >> 8);
;;;1888   
;;;1889     /* Clear the selected ADC interrupt pending bits */
;;;1890     ADCx->SR = ~(uint32_t)itmask;
000004  6001              STR      r1,[r0,#0]
;;;1891   }
000006  4770              BX       lr
;;;1892   
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;355      */
;;;356    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;357    {
;;;358      /* Check the parameters */
;;;359      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;360      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;361    
;;;362      if (NewState != DISABLE)
;;;363      {
;;;364        /* Set the ADON bit to wake up the ADC from power down mode */
;;;365        ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
;;;366      }
;;;367      else
;;;368      {
;;;369        /* Disable the selected ADC peripheral */
;;;370        ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L8.12|
000006  f0410101          ORR      r1,r1,#1              ;365
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L8.16|
000010  6081              STR      r1,[r0,#8]            ;365
;;;371      }
;;;372    }
000012  4770              BX       lr
;;;373    
                          ENDP


                          AREA ||i.ADC_CommonInit||, CODE, READONLY, ALIGN=2

                  ADC_CommonInit PROC
;;;314      */
;;;315    void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                           
000000  4903              LDR      r1,|L9.16|
;;;316    {
;;;317      uint32_t tmpreg = 0;
;;;318      
;;;319      /* Check the parameters */
;;;320      assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
;;;321    
;;;322      /*---------------------------- ADC CCR Configuration -----------------*/
;;;323      /* Get the ADC CCR value */
;;;324      tmpreg = ADC->CCR;
000002  680a              LDR      r2,[r1,#0]
;;;325    
;;;326      /* Clear ADCPRE bit */ 
;;;327      tmpreg &= CR_CLEAR_MASK;
;;;328      
;;;329      /* Configure ADCx: ADC prescaler according to ADC_Prescaler */                
;;;330      tmpreg |= (uint32_t)(ADC_CommonInitStruct->ADC_Prescaler);        
000004  6800              LDR      r0,[r0,#0]
000006  f4223240          BIC      r2,r2,#0x30000        ;327
00000a  4310              ORRS     r0,r0,r2
;;;331                    
;;;332      /* Write to ADC CCR */
;;;333      ADC->CCR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;334    }
00000e  4770              BX       lr
;;;335    
                          ENDP

                  |L9.16|
                          DCD      0x40012704

                          AREA ||i.ADC_CommonStructInit||, CODE, READONLY, ALIGN=1

                  ADC_CommonStructInit PROC
;;;341      */
;;;342    void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                      
000000  2100              MOVS     r1,#0
;;;343    {
;;;344      /* Reset ADC init structure parameters values */
;;;345      /* Initialize the ADC_Prescaler member */
;;;346      ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div1;
000002  6001              STR      r1,[r0,#0]
;;;347    }
000004  4770              BX       lr
;;;348    
                          ENDP


                          AREA ||i.ADC_ContinuousModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_ContinuousModeCmd PROC
;;;1051     */
;;;1052   void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1056     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1057   
;;;1058     if (NewState != DISABLE)
;;;1059     {
;;;1060       /* Enable the selected ADC continuous conversion mode */
;;;1061       ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
;;;1062     }
;;;1063     else
;;;1064     {
;;;1065       /* Disable the selected ADC continuous conversion mode */
;;;1066       ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L11.12|
000006  f0410102          ORR      r1,r1,#2              ;1061
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L11.16|
000010  6081              STR      r1,[r0,#8]            ;1061
;;;1067     }
;;;1068   }
000012  4770              BX       lr
;;;1069   
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;1173     */
;;;1174   void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1175   {
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;1178     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1179   
;;;1180     if (NewState != DISABLE)
;;;1181     {
;;;1182       /* Enable the selected ADC DMA request */
;;;1183       ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
;;;1184     }
;;;1185     else
;;;1186     {
;;;1187       /* Disable the selected ADC DMA request */
;;;1188       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L12.12|
000006  f4417180          ORR      r1,r1,#0x100          ;1183
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L12.16|
000010  6081              STR      r1,[r0,#8]            ;1183
;;;1189     }
;;;1190   }
000012  4770              BX       lr
;;;1191   
                          ENDP


                          AREA ||i.ADC_DMARequestAfterLastTransferCmd||, CODE, READONLY, ALIGN=1

                  ADC_DMARequestAfterLastTransferCmd PROC
;;;1199     */
;;;1200   void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1201   {
;;;1202     /* Check the parameters */
;;;1203     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1204     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1205   
;;;1206     if (NewState != DISABLE)
;;;1207     {
;;;1208       /* Enable the selected ADC DMA request after last transfer */
;;;1209       ADCx->CR2 |= ADC_CR2_DDS;
;;;1210     }
;;;1211     else
;;;1212     {
;;;1213       /* Disable the selected ADC DMA request after last transfer */
;;;1214       ADCx->CR2 &= (uint32_t)~ADC_CR2_DDS;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L13.12|
000006  f4417100          ORR      r1,r1,#0x200          ;1209
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f4217100          BIC      r1,r1,#0x200
                  |L13.16|
000010  6081              STR      r1,[r0,#8]            ;1209
;;;1215     }
;;;1216   }
000012  4770              BX       lr
;;;1217   
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;189      */
;;;190    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  4907              LDR      r1,|L14.32|
;;;191    {
000002  b510              PUSH     {r4,lr}
;;;192      /* Check the parameters */
;;;193      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;194    
;;;195      if(ADCx == ADC1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L14.30|
;;;196      {
;;;197        /* Enable ADC1 reset state */
;;;198        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
000008  1544              ASRS     r4,r0,#21
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;199        /* Release ADC1 from reset state */
;;;200        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L14.30|
;;;201      }
;;;202    }
00001e  bd10              POP      {r4,pc}
;;;203    
                          ENDP

                  |L14.32|
                          DCD      0x40012400

                          AREA ||i.ADC_DelaySelectionConfig||, CODE, READONLY, ALIGN=1

                  ADC_DelaySelectionConfig PROC
;;;498      */
;;;499    void ADC_DelaySelectionConfig(ADC_TypeDef* ADCx, uint8_t ADC_DelayLength)
000000  6882              LDR      r2,[r0,#8]
;;;500    {
;;;501      uint32_t tmpreg = 0;
;;;502       
;;;503      /* Check the parameters */
;;;504      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;505      assert_param(IS_ADC_DELAY_LENGTH(ADC_DelayLength));
;;;506    
;;;507      /* Get the old register value */    
;;;508      tmpreg = ADCx->CR2;
;;;509      /* Clear the old delay length */
;;;510      tmpreg &= CR2_DELS_RESET;
000002  f02202f0          BIC      r2,r2,#0xf0
;;;511      /* Set the delay length */
;;;512      tmpreg |= ADC_DelayLength;
000006  430a              ORRS     r2,r2,r1
;;;513      /* Store the new register value */
;;;514      ADCx->CR2 = tmpreg;
000008  6082              STR      r2,[r0,#8]
;;;515    
;;;516    }
00000a  4770              BX       lr
;;;517    
                          ENDP


                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;1077     */
;;;1078   void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  6842              LDR      r2,[r0,#4]
;;;1079   {
;;;1080     uint32_t tmpreg1 = 0;
;;;1081     uint32_t tmpreg2 = 0;
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1085     assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;1086   
;;;1087     /* Get the old register value */
;;;1088     tmpreg1 = ADCx->CR1;
;;;1089     /* Clear the old discontinuous mode channel count */
;;;1090     tmpreg1 &= CR1_DISCNUM_RESET;
000002  1e49              SUBS     r1,r1,#1
000004  f4224260          BIC      r2,r2,#0xe000
;;;1091     /* Set the discontinuous mode channel count */
;;;1092     tmpreg2 = Number - 1;
;;;1093     tmpreg1 |= tmpreg2 << 13;
000008  ea423141          ORR      r1,r2,r1,LSL #13
;;;1094     /* Store the new register value */
;;;1095     ADCx->CR1 = tmpreg1;
00000c  6041              STR      r1,[r0,#4]
;;;1096   }
00000e  4770              BX       lr
;;;1097   
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;1106     */
;;;1107   void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1108   {
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1111     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1112   
;;;1113     if (NewState != DISABLE)
;;;1114     {
;;;1115       /* Enable the selected ADC regular discontinuous mode */
;;;1116       ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
;;;1117     }
;;;1118     else
;;;1119     {
;;;1120       /* Disable the selected ADC regular discontinuous mode */
;;;1121       ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L17.12|
000006  f4416100          ORR      r1,r1,#0x800          ;1116
00000a  e001              B        |L17.16|
                  |L17.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L17.16|
000010  6041              STR      r1,[r0,#4]            ;1116
;;;1122     }
;;;1123   }
000012  4770              BX       lr
;;;1124   
                          ENDP


                          AREA ||i.ADC_EOCOnEachRegularChannelCmd||, CODE, READONLY, ALIGN=1

                  ADC_EOCOnEachRegularChannelCmd PROC
;;;1026     */
;;;1027   void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1028   {
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1031     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1032   
;;;1033     if (NewState != DISABLE)
;;;1034     {
;;;1035       /* Enable the selected ADC EOC rising on each regular channel conversion */
;;;1036       ADCx->CR2 |= ADC_CR2_EOCS;
;;;1037     }
;;;1038     else
;;;1039     {
;;;1040       /* Disable the selected ADC EOC rising on each regular channel conversion */
;;;1041       ADCx->CR2 &= (uint32_t)~ADC_CR2_EOCS;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L18.12|
000006  f4416180          ORR      r1,r1,#0x400          ;1036
00000a  e001              B        |L18.16|
                  |L18.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L18.16|
000010  6081              STR      r1,[r0,#8]            ;1036
;;;1042     }
;;;1043   }
000012  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;1477     */
;;;1478   void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000000  6882              LDR      r2,[r0,#8]
;;;1479   {
;;;1480     uint32_t tmpreg = 0;
;;;1481   
;;;1482     /* Check the parameters */
;;;1483     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1484     assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;1485   
;;;1486     /* Get the old register value */
;;;1487     tmpreg = ADCx->CR2;
;;;1488     /* Clear the old external event selection for injected group */
;;;1489     tmpreg &= CR2_JEXTSEL_RESET;
000002  f4222270          BIC      r2,r2,#0xf0000
;;;1490     /* Set the external event selection for injected group */
;;;1491     tmpreg |= ADC_ExternalTrigInjecConv;
000006  430a              ORRS     r2,r2,r1
;;;1492     /* Store the new register value */
;;;1493     ADCx->CR2 = tmpreg;
000008  6082              STR      r2,[r0,#8]
;;;1494   }
00000a  4770              BX       lr
;;;1495   
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvEdgeConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvEdgeConfig PROC
;;;1509     */
;;;1510   void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
000000  6882              LDR      r2,[r0,#8]
;;;1511   {
;;;1512     uint32_t tmpreg = 0;
;;;1513   
;;;1514     /* Check the parameters */
;;;1515     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1516     assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
;;;1517   
;;;1518     /* Get the old register value */
;;;1519     tmpreg = ADCx->CR2;
;;;1520     /* Clear the old external trigger edge for injected group */
;;;1521     tmpreg &= CR2_JEXTEN_RESET;
000002  f4221240          BIC      r2,r2,#0x300000
;;;1522     /* Set the new external trigger edge for injected group */
;;;1523     tmpreg |= ADC_ExternalTrigInjecConvEdge;
000006  430a              ORRS     r2,r2,r1
;;;1524     /* Store the new register value */
;;;1525     ADCx->CR2 = tmpreg;
000008  6082              STR      r2,[r0,#8]
;;;1526   }
00000a  4770              BX       lr
;;;1527   
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;1129     */
;;;1130   uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  6d80              LDR      r0,[r0,#0x58]
;;;1131   {
;;;1132     /* Check the parameters */
;;;1133     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1134   
;;;1135     /* Return the selected ADC conversion value */
;;;1136     return (uint16_t) ADCx->DR;
000002  b280              UXTH     r0,r0
;;;1137   }
000004  4770              BX       lr
;;;1138   
                          ENDP


                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;1779     */
;;;1780   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
000000  4602              MOV      r2,r0
;;;1781   {
;;;1782     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1783   
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1786     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1787   
;;;1788     /* Check the status of the specified ADC flag */
;;;1789     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L22.12|
;;;1790     {
;;;1791       /* ADC_FLAG is set */
;;;1792       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L22.12|
;;;1793     }
;;;1794     else
;;;1795     {
;;;1796       /* ADC_FLAG is reset */
;;;1797       bitstatus = RESET;
;;;1798     }
;;;1799     /* Return the ADC_FLAG status */
;;;1800     return  bitstatus;
;;;1801   }
00000c  4770              BX       lr
;;;1802   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1836     */
;;;1837   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1838   {
000002  4602              MOV      r2,r0
;;;1839     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1840     uint32_t itmask = 0, enablestatus = 0;
;;;1841   
;;;1842     /* Check the parameters */
;;;1843     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1844     assert_param(IS_ADC_IT(ADC_IT));
;;;1845   
;;;1846     /* Get the ADC IT index */
;;;1847     itmask = (uint32_t)((uint32_t)ADC_IT >> 8);
;;;1848   
;;;1849     /* Get the ADC_IT enable bit status */
;;;1850     enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)); 
000006  6853              LDR      r3,[r2,#4]
000008  0a0c              LSRS     r4,r1,#8              ;1847
00000a  2501              MOVS     r5,#1
00000c  408d              LSLS     r5,r5,r1
;;;1851   
;;;1852     /* Check the status of the specified ADC interrupt */
;;;1853     if (((uint32_t)(ADCx->SR & (uint32_t)itmask) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
00000e  6811              LDR      r1,[r2,#0]
000010  402b              ANDS     r3,r3,r5              ;1850
000012  4221              TST      r1,r4
000014  d002              BEQ      |L23.28|
000016  2b00              CMP      r3,#0
000018  d000              BEQ      |L23.28|
;;;1854     {                                                         
;;;1855       /* ADC_IT is set */
;;;1856       bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L23.28|
;;;1857     }
;;;1858     else
;;;1859     {
;;;1860       /* ADC_IT is reset */
;;;1861       bitstatus = RESET;
;;;1862     }
;;;1863     /* Return the ADC_IT status */
;;;1864     return  bitstatus;
;;;1865   }
00001c  bd30              POP      {r4,r5,pc}
;;;1866   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;1632     */
;;;1633   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000000  b508              PUSH     {r3,lr}
;;;1634   {
;;;1635     __IO uint32_t tmp = 0;
;;;1636     
;;;1637     /* Check the parameters */
;;;1638     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1639     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1640   
;;;1641     tmp = (uint32_t)ADCx;
;;;1642     tmp += ADC_InjectedChannel + JDR_OFFSET;
000002  4408              ADD      r0,r0,r1
000004  3030              ADDS     r0,r0,#0x30
;;;1643     
;;;1644     /* Returns the selected injected channel conversion data value */
;;;1645     return (uint16_t) (*(__IO uint32_t*)  tmp); 
000006  9000              STR      r0,[sp,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  b280              UXTH     r0,r0
;;;1646   }
00000c  bd08              POP      {r3,pc}
;;;1647   
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartConvStatus PROC
;;;997      */
;;;998    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;999    {
;;;1000     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1001   
;;;1002     /* Check the parameters */
;;;1003     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1004   
;;;1005     /* Check the status of SWSTART bit */
;;;1006     if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0049              LSLS     r1,r1,#1
000008  d500              BPL      |L25.12|
;;;1007     {
;;;1008       /* SWSTART bit is set */
;;;1009       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L25.12|
;;;1010     }
;;;1011     else
;;;1012     {
;;;1013       /* SWSTART bit is reset */
;;;1014       bitstatus = RESET;
;;;1015     }
;;;1016     /* Return the SWSTART bit status */
;;;1017     return  bitstatus;
;;;1018   }
00000c  4770              BX       lr
;;;1019   
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;1546     */
;;;1547   FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;1548   {
;;;1549     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1550   
;;;1551     /* Check the parameters */
;;;1552     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1553   
;;;1554     /* Check the status of JSWSTART bit */
;;;1555     if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0249              LSLS     r1,r1,#9
000008  d500              BPL      |L26.12|
;;;1556     {
;;;1557       /* JSWSTART bit is set */
;;;1558       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L26.12|
;;;1559     }
;;;1560     else
;;;1561     {
;;;1562       /* JSWSTART bit is reset */
;;;1563       bitstatus = RESET;
;;;1564     }
;;;1565     /* Return the JSWSTART bit status */
;;;1566     return  bitstatus;
;;;1567   }
00000c  4770              BX       lr
;;;1568   
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;1738     */
;;;1739   void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
000000  2301              MOVS     r3,#1
;;;1740   {
;;;1741     uint32_t itmask = 0;
;;;1742   
;;;1743     /* Check the parameters */
;;;1744     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1745     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1746     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1747   
;;;1748     /* Get the ADC IT index */
;;;1749     itmask = (uint8_t)ADC_IT;
;;;1750     itmask = (uint32_t)0x01 << itmask;    
000002  408b              LSLS     r3,r3,r1
;;;1751   
;;;1752     if (NewState != DISABLE)
;;;1753     {
;;;1754       /* Enable the selected ADC interrupts */
;;;1755       ADCx->CR1 |= itmask;
;;;1756     }
;;;1757     else
;;;1758     {
;;;1759       /* Disable the selected ADC interrupts */
;;;1760       ADCx->CR1 &= (~(uint32_t)itmask);
000004  6841              LDR      r1,[r0,#4]
000006  b10a              CBZ      r2,|L27.12|
000008  4319              ORRS     r1,r1,r3              ;1755
00000a  e000              B        |L27.14|
                  |L27.12|
00000c  4399              BICS     r1,r1,r3
                  |L27.14|
00000e  6041              STR      r1,[r0,#4]            ;1755
;;;1761     }
;;;1762   }
000010  4770              BX       lr
;;;1763   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;216      */
;;;217    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)               
000000  b530              PUSH     {r4,r5,lr}
;;;218    {
;;;219      uint32_t tmpreg1 = 0;
;;;220      uint8_t tmpreg2 = 0;
;;;221      
;;;222      /* Check the parameters */
;;;223      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;224      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
;;;225      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;226      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
;;;227      assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
;;;228      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
;;;229      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;230      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
;;;231      
;;;232      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;233      /* Get the ADCx CR1 value */
;;;234      tmpreg1 = ADCx->CR1;
000002  6842              LDR      r2,[r0,#4]
;;;235      /* Clear RES and SCAN bits */ 
;;;236      tmpreg1 &= CR1_CLEAR_MASK;
000004  4b0f              LDR      r3,|L28.68|
;;;237      /* Configure ADCx: scan conversion mode and resolution */
;;;238      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;239      /* Set RES bit according to ADC_Resolution value */ 
;;;240      tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | ADC_InitStruct->ADC_Resolution);
000006  790c              LDRB     r4,[r1,#4]
000008  401a              ANDS     r2,r2,r3              ;236
00000a  680b              LDR      r3,[r1,#0]
00000c  ea422204          ORR      r2,r2,r4,LSL #8
000010  4313              ORRS     r3,r3,r2
;;;241      /* Write to ADCx CR1 */
;;;242      ADCx->CR1 = tmpreg1;
000012  6043              STR      r3,[r0,#4]
;;;243      
;;;244      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;245      /* Get the ADCx CR2 value */
;;;246      tmpreg1 = ADCx->CR2;
000014  6882              LDR      r2,[r0,#8]
;;;247      /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
;;;248      tmpreg1 &= CR2_CLEAR_MASK;
000016  4b0c              LDR      r3,|L28.72|
;;;249      /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
;;;250      /* Set ALIGN bit according to ADC_DataAlign value */
;;;251      /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
;;;252      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;253      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;254      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
000018  794d              LDRB     r5,[r1,#5]
00001a  401a              ANDS     r2,r2,r3              ;248
00001c  e9d14303          LDRD     r4,r3,[r1,#0xc]       ;248
000020  4323              ORRS     r3,r3,r4
000022  688c              LDR      r4,[r1,#8]
000024  ea440445          ORR      r4,r4,r5,LSL #1
000028  4323              ORRS     r3,r3,r4
00002a  4313              ORRS     r3,r3,r2
;;;255                  ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;256      /* Write to ADCx CR2 */
;;;257      ADCx->CR2 = tmpreg1;
00002c  6083              STR      r3,[r0,#8]
;;;258      
;;;259      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;260      /* Get the ADCx SQR1 value */
;;;261      tmpreg1 = ADCx->SQR1;
00002e  6b02              LDR      r2,[r0,#0x30]
;;;262      /* Clear L bits */
;;;263      tmpreg1 &= SQR1_L_RESET;
;;;264      /* Configure ADCx: regular channel sequence length */
;;;265      /* Set L bits according to ADC_NbrOfConversion value */ 
;;;266      tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
000030  7d09              LDRB     r1,[r1,#0x14]
000032  f02272f8          BIC      r2,r2,#0x1f00000      ;263
000036  1e49              SUBS     r1,r1,#1
000038  b2c9              UXTB     r1,r1
;;;267      tmpreg1 |= ((uint32_t)tmpreg2 << 20);
00003a  ea425101          ORR      r1,r2,r1,LSL #20
;;;268      /* Write to ADCx SQR1 */
;;;269      ADCx->SQR1 = tmpreg1;
00003e  6301              STR      r1,[r0,#0x30]
;;;270    }
000040  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP

000042  0000              DCW      0x0000
                  |L28.68|
                          DCD      0xfcfffeff
                  |L28.72|
                          DCD      0xc0fff7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelConfig PROC
;;;1311     */
;;;1312   void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;1313   {
;;;1314     uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;1315   
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1318     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1319     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1320     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1321     
;;;1322     /* If ADC_Channel_30 or ADC_Channel_31 is selected */
;;;1323     if (ADC_Channel > ADC_Channel_29)
;;;1324     {
;;;1325       /* Get the old register value */
;;;1326       tmpreg1 = ADCx->SMPR0;
;;;1327       /* Calculate the mask to clear */
;;;1328       tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
000002  2407              MOVS     r4,#7
000004  291d              CMP      r1,#0x1d              ;1323
000006  d90a              BLS      |L29.30|
000008  6dc5              LDR      r5,[r0,#0x5c]         ;1326
00000a  f1a1061e          SUB      r6,r1,#0x1e
00000e  eb060646          ADD      r6,r6,r6,LSL #1
000012  40b4              LSLS     r4,r4,r6
;;;1329       /* Clear the old sample time */
;;;1330       tmpreg1 &= ~tmpreg2;
000014  43a5              BICS     r5,r5,r4
;;;1331       /* Calculate the mask to set */
;;;1332       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
000016  40b3              LSLS     r3,r3,r6
;;;1333       /* Set the new sample time */
;;;1334       tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;1335       /* Store the new register value */
;;;1336       ADCx->SMPR0 = tmpreg1;
00001a  65c5              STR      r5,[r0,#0x5c]
00001c  e021              B        |L29.98|
                  |L29.30|
;;;1337     }
;;;1338     /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
;;;1339     else if (ADC_Channel > ADC_Channel_19)
00001e  2913              CMP      r1,#0x13
000020  d90a              BLS      |L29.56|
;;;1340     {
;;;1341       /* Get the old register value */
;;;1342       tmpreg1 = ADCx->SMPR1;
000022  68c5              LDR      r5,[r0,#0xc]
;;;1343       /* Calculate the mask to clear */
;;;1344       tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
000024  f1a10614          SUB      r6,r1,#0x14
000028  eb060646          ADD      r6,r6,r6,LSL #1
00002c  40b4              LSLS     r4,r4,r6
;;;1345       /* Clear the old sample time */
;;;1346       tmpreg1 &= ~tmpreg2;
00002e  43a5              BICS     r5,r5,r4
;;;1347       /* Calculate the mask to set */
;;;1348       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
000030  40b3              LSLS     r3,r3,r6
;;;1349       /* Set the new sample time */
;;;1350       tmpreg1 |= tmpreg2;
000032  431d              ORRS     r5,r5,r3
;;;1351       /* Store the new register value */
;;;1352       ADCx->SMPR1 = tmpreg1;
000034  60c5              STR      r5,[r0,#0xc]
000036  e014              B        |L29.98|
                  |L29.56|
;;;1353     }  
;;;1354     /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
;;;1355     else if (ADC_Channel > ADC_Channel_9)
000038  2909              CMP      r1,#9
00003a  d90a              BLS      |L29.82|
;;;1356     {
;;;1357       /* Get the old register value */
;;;1358       tmpreg1 = ADCx->SMPR2;
00003c  6905              LDR      r5,[r0,#0x10]
;;;1359       /* Calculate the mask to clear */
;;;1360       tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
00003e  f1a1060a          SUB      r6,r1,#0xa
000042  eb060646          ADD      r6,r6,r6,LSL #1
000046  40b4              LSLS     r4,r4,r6
;;;1361       /* Clear the old sample time */
;;;1362       tmpreg1 &= ~tmpreg2;
000048  43a5              BICS     r5,r5,r4
;;;1363       /* Calculate the mask to set */
;;;1364       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
00004a  40b3              LSLS     r3,r3,r6
;;;1365       /* Set the new sample time */
;;;1366       tmpreg1 |= tmpreg2;
00004c  431d              ORRS     r5,r5,r3
;;;1367       /* Store the new register value */
;;;1368       ADCx->SMPR2 = tmpreg1;
00004e  6105              STR      r5,[r0,#0x10]
000050  e007              B        |L29.98|
                  |L29.82|
;;;1369     }
;;;1370     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1371     {
;;;1372       /* Get the old register value */
;;;1373       tmpreg1 = ADCx->SMPR3;
000052  6945              LDR      r5,[r0,#0x14]
;;;1374       /* Calculate the mask to clear */
;;;1375       tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
000054  eb010641          ADD      r6,r1,r1,LSL #1
000058  40b4              LSLS     r4,r4,r6
;;;1376       /* Clear the old sample time */
;;;1377       tmpreg1 &= ~tmpreg2;
00005a  43a5              BICS     r5,r5,r4
;;;1378       /* Calculate the mask to set */
;;;1379       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
00005c  40b3              LSLS     r3,r3,r6
;;;1380       /* Set the new sample time */
;;;1381       tmpreg1 |= tmpreg2;
00005e  431d              ORRS     r5,r5,r3
;;;1382       /* Store the new register value */
;;;1383       ADCx->SMPR3 = tmpreg1;
000060  6145              STR      r5,[r0,#0x14]
                  |L29.98|
;;;1384     }
;;;1385     
;;;1386     /* Rank configuration */
;;;1387     /* Get the old register value */
;;;1388     tmpreg1 = ADCx->JSQR;
000062  6c43              LDR      r3,[r0,#0x44]
;;;1389     /* Get JL value: Number = JL+1 */
;;;1390     tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
000064  f3c35401          UBFX     r4,r3,#20,#2
;;;1391     /* Calculate the mask to clear: ((Rank-1)+(4- (JL+1))) */ 
;;;1392     tmpreg2 = (uint32_t)(JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
000068  1b12              SUBS     r2,r2,r4
00006a  1c92              ADDS     r2,r2,#2
00006c  eb020482          ADD      r4,r2,r2,LSL #2
000070  221f              MOVS     r2,#0x1f
000072  40a2              LSLS     r2,r2,r4
;;;1393     /* Clear the old JSQx bits for the selected rank */
;;;1394     tmpreg1 &= ~tmpreg2;
000074  4393              BICS     r3,r3,r2
;;;1395     /* Calculate the mask to set: ((Rank-1)+(4- (JL+1))) */ 
;;;1396     tmpreg2 = (uint32_t)(((uint32_t)(ADC_Channel)) << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
000076  40a1              LSLS     r1,r1,r4
;;;1397     /* Set the JSQx bits for the selected rank */
;;;1398     tmpreg1 |= tmpreg2;
000078  430b              ORRS     r3,r3,r1
;;;1399     /* Store the new register value */
;;;1400     ADCx->JSQR = tmpreg1;
00007a  6443              STR      r3,[r0,#0x44]
;;;1401   }
00007c  bd70              POP      {r4-r6,pc}
;;;1402   
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;1603     */
;;;1604   void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1605   {
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1608     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1609   
;;;1610     if (NewState != DISABLE)
;;;1611     {
;;;1612       /* Enable the selected ADC injected discontinuous mode */
;;;1613       ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
;;;1614     }
;;;1615     else
;;;1616     {
;;;1617       /* Disable the selected ADC injected discontinuous mode */
;;;1618       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L30.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;1613
00000a  e001              B        |L30.16|
                  |L30.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L30.16|
000010  6041              STR      r1,[r0,#4]            ;1613
;;;1619     }
;;;1620   }
000012  4770              BX       lr
;;;1621   
                          ENDP


                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedSequencerLengthConfig PROC
;;;1409     */
;;;1410   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000000  6c42              LDR      r2,[r0,#0x44]
;;;1411   {
;;;1412     uint32_t tmpreg1 = 0;
;;;1413     uint32_t tmpreg2 = 0;
;;;1414   
;;;1415     /* Check the parameters */
;;;1416     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1417     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1418     
;;;1419     /* Get the old register value */
;;;1420     tmpreg1 = ADCx->JSQR;
;;;1421     /* Clear the old injected sequence length JL bits */
;;;1422     tmpreg1 &= JSQR_JL_RESET;
000002  1e49              SUBS     r1,r1,#1
000004  f4221240          BIC      r2,r2,#0x300000
;;;1423     /* Set the injected sequence length JL bits */
;;;1424     tmpreg2 = Length - 1; 
;;;1425     tmpreg1 |= tmpreg2 << 20;
000008  ea425101          ORR      r1,r2,r1,LSL #20
;;;1426     /* Store the new register value */
;;;1427     ADCx->JSQR = tmpreg1;
00000c  6441              STR      r1,[r0,#0x44]
;;;1428   }
00000e  4770              BX       lr
;;;1429   
                          ENDP


                          AREA ||i.ADC_PowerDownCmd||, CODE, READONLY, ALIGN=1

                  ADC_PowerDownCmd PROC
;;;447      */
;;;448    void ADC_PowerDownCmd(ADC_TypeDef* ADCx, uint32_t ADC_PowerDown, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;452      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;453      assert_param(IS_ADC_POWER_DOWN(ADC_PowerDown));
;;;454      
;;;455      if (NewState != DISABLE)
;;;456      {
;;;457        /* Enable the ADC power-down during Delay and/or Idle phase */
;;;458        ADCx->CR1 |= ADC_PowerDown;
;;;459      }
;;;460      else
;;;461      {
;;;462        /* Disable The ADC power-down during Delay and/or Idle phase */
;;;463        ADCx->CR1 &= (uint32_t)~ADC_PowerDown;
000002  6842              LDR      r2,[r0,#4]
000004  d001              BEQ      |L32.10|
000006  430a              ORRS     r2,r2,r1              ;458
000008  e000              B        |L32.12|
                  |L32.10|
00000a  438a              BICS     r2,r2,r1
                  |L32.12|
00000c  6042              STR      r2,[r0,#4]            ;458
;;;464      }
;;;465    }
00000e  4770              BX       lr
;;;466    
                          ENDP


                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;821      */
;;;822    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;823    {
;;;824      uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;825    
;;;826      /* Check the parameters */
;;;827      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;828      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;829      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;830      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;831    
;;;832      /* If ADC_Channel_30 or ADC_Channel_31 is selected */
;;;833      if (ADC_Channel > ADC_Channel_29)
;;;834      {
;;;835        /* Get the old register value */
;;;836        tmpreg1 = ADCx->SMPR0;
;;;837        /* Calculate the mask to clear */
;;;838        tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
000002  2407              MOVS     r4,#7
000004  291d              CMP      r1,#0x1d              ;833
000006  d90a              BLS      |L33.30|
000008  6dc5              LDR      r5,[r0,#0x5c]         ;836
00000a  f1a1061e          SUB      r6,r1,#0x1e
00000e  eb060646          ADD      r6,r6,r6,LSL #1
000012  40b4              LSLS     r4,r4,r6
;;;839        /* Clear the old sample time */
;;;840        tmpreg1 &= ~tmpreg2;
000014  43a5              BICS     r5,r5,r4
;;;841        /* Calculate the mask to set */
;;;842        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
000016  40b3              LSLS     r3,r3,r6
;;;843        /* Set the new sample time */
;;;844        tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;845        /* Store the new register value */
;;;846        ADCx->SMPR0 = tmpreg1;
00001a  65c5              STR      r5,[r0,#0x5c]
00001c  e021              B        |L33.98|
                  |L33.30|
;;;847      }
;;;848      /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
;;;849      else if (ADC_Channel > ADC_Channel_19)
00001e  2913              CMP      r1,#0x13
000020  d90a              BLS      |L33.56|
;;;850      {
;;;851        /* Get the old register value */
;;;852        tmpreg1 = ADCx->SMPR1;
000022  68c5              LDR      r5,[r0,#0xc]
;;;853        /* Calculate the mask to clear */
;;;854        tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
000024  f1a10614          SUB      r6,r1,#0x14
000028  eb060646          ADD      r6,r6,r6,LSL #1
00002c  40b4              LSLS     r4,r4,r6
;;;855        /* Clear the old sample time */
;;;856        tmpreg1 &= ~tmpreg2;
00002e  43a5              BICS     r5,r5,r4
;;;857        /* Calculate the mask to set */
;;;858        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
000030  40b3              LSLS     r3,r3,r6
;;;859        /* Set the new sample time */
;;;860        tmpreg1 |= tmpreg2;
000032  431d              ORRS     r5,r5,r3
;;;861        /* Store the new register value */
;;;862        ADCx->SMPR1 = tmpreg1;
000034  60c5              STR      r5,[r0,#0xc]
000036  e014              B        |L33.98|
                  |L33.56|
;;;863      }
;;;864      /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
;;;865      else if (ADC_Channel > ADC_Channel_9)
000038  2909              CMP      r1,#9
00003a  d90a              BLS      |L33.82|
;;;866      {
;;;867        /* Get the old register value */
;;;868        tmpreg1 = ADCx->SMPR2;
00003c  6905              LDR      r5,[r0,#0x10]
;;;869        /* Calculate the mask to clear */
;;;870        tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
00003e  f1a1060a          SUB      r6,r1,#0xa
000042  eb060646          ADD      r6,r6,r6,LSL #1
000046  40b4              LSLS     r4,r4,r6
;;;871        /* Clear the old sample time */
;;;872        tmpreg1 &= ~tmpreg2;
000048  43a5              BICS     r5,r5,r4
;;;873        /* Calculate the mask to set */
;;;874        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
00004a  40b3              LSLS     r3,r3,r6
;;;875        /* Set the new sample time */
;;;876        tmpreg1 |= tmpreg2;
00004c  431d              ORRS     r5,r5,r3
;;;877        /* Store the new register value */
;;;878        ADCx->SMPR2 = tmpreg1;
00004e  6105              STR      r5,[r0,#0x10]
000050  e007              B        |L33.98|
                  |L33.82|
;;;879      }
;;;880      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;881      {
;;;882        /* Get the old register value */
;;;883        tmpreg1 = ADCx->SMPR3;
000052  6945              LDR      r5,[r0,#0x14]
;;;884        /* Calculate the mask to clear */
;;;885        tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
000054  eb010641          ADD      r6,r1,r1,LSL #1
000058  40b4              LSLS     r4,r4,r6
;;;886        /* Clear the old sample time */
;;;887        tmpreg1 &= ~tmpreg2;
00005a  43a5              BICS     r5,r5,r4
;;;888        /* Calculate the mask to set */
;;;889        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
00005c  40b3              LSLS     r3,r3,r6
;;;890        /* Set the new sample time */
;;;891        tmpreg1 |= tmpreg2;
00005e  431d              ORRS     r5,r5,r3
;;;892        /* Store the new register value */
;;;893        ADCx->SMPR3 = tmpreg1;
000060  6145              STR      r5,[r0,#0x14]
                  |L33.98|
;;;894      }
;;;895      /* For Rank 1 to 6 */
;;;896      if (Rank < 7)
;;;897      {
;;;898        /* Get the old register value */
;;;899        tmpreg1 = ADCx->SQR5;
;;;900        /* Calculate the mask to clear */
;;;901        tmpreg2 = SQR5_SQ_SET << (5 * (Rank - 1));
000062  231f              MOVS     r3,#0x1f
000064  2a07              CMP      r2,#7                 ;896
000066  d209              BCS      |L33.124|
000068  6c04              LDR      r4,[r0,#0x40]         ;899
00006a  1e52              SUBS     r2,r2,#1              ;899
00006c  eb020282          ADD      r2,r2,r2,LSL #2
000070  4093              LSLS     r3,r3,r2
;;;902        /* Clear the old SQx bits for the selected rank */
;;;903        tmpreg1 &= ~tmpreg2;
000072  439c              BICS     r4,r4,r3
;;;904        /* Calculate the mask to set */
;;;905        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
000074  4091              LSLS     r1,r1,r2
;;;906        /* Set the SQx bits for the selected rank */
;;;907        tmpreg1 |= tmpreg2;
000076  430c              ORRS     r4,r4,r1
;;;908        /* Store the new register value */
;;;909        ADCx->SQR5 = tmpreg1;
000078  6404              STR      r4,[r0,#0x40]
;;;910      }
;;;911      /* For Rank 7 to 12 */
;;;912      else if (Rank < 13)
;;;913      {
;;;914        /* Get the old register value */
;;;915        tmpreg1 = ADCx->SQR4;
;;;916        /* Calculate the mask to clear */
;;;917        tmpreg2 = SQR4_SQ_SET << (5 * (Rank - 7));
;;;918        /* Clear the old SQx bits for the selected rank */
;;;919        tmpreg1 &= ~tmpreg2;
;;;920        /* Calculate the mask to set */
;;;921        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
;;;922        /* Set the SQx bits for the selected rank */
;;;923        tmpreg1 |= tmpreg2;
;;;924        /* Store the new register value */
;;;925        ADCx->SQR4 = tmpreg1;
;;;926      }  
;;;927      /* For Rank 13 to 18 */
;;;928      else if (Rank < 19)
;;;929      {
;;;930        /* Get the old register value */
;;;931        tmpreg1 = ADCx->SQR3;
;;;932        /* Calculate the mask to clear */
;;;933        tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 13));
;;;934        /* Clear the old SQx bits for the selected rank */
;;;935        tmpreg1 &= ~tmpreg2;
;;;936        /* Calculate the mask to set */
;;;937        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
;;;938        /* Set the SQx bits for the selected rank */
;;;939        tmpreg1 |= tmpreg2;
;;;940        /* Store the new register value */
;;;941        ADCx->SQR3 = tmpreg1;
;;;942      }
;;;943        
;;;944      /* For Rank 19 to 24 */
;;;945      else if (Rank < 25)
;;;946      {
;;;947        /* Get the old register value */
;;;948        tmpreg1 = ADCx->SQR2;
;;;949        /* Calculate the mask to clear */
;;;950        tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 19));
;;;951        /* Clear the old SQx bits for the selected rank */
;;;952        tmpreg1 &= ~tmpreg2;
;;;953        /* Calculate the mask to set */
;;;954        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 19));
;;;955        /* Set the SQx bits for the selected rank */
;;;956        tmpreg1 |= tmpreg2;
;;;957        /* Store the new register value */
;;;958        ADCx->SQR2 = tmpreg1;
;;;959      }   
;;;960      
;;;961      /* For Rank 25 to 28 */
;;;962      else
;;;963      {
;;;964        /* Get the old register value */
;;;965        tmpreg1 = ADCx->SQR1;
;;;966        /* Calculate the mask to clear */
;;;967        tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 25));
;;;968        /* Clear the old SQx bits for the selected rank */
;;;969        tmpreg1 &= ~tmpreg2;
;;;970        /* Calculate the mask to set */
;;;971        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 25));
;;;972        /* Set the SQx bits for the selected rank */
;;;973        tmpreg1 |= tmpreg2;
;;;974        /* Store the new register value */
;;;975        ADCx->SQR1 = tmpreg1;
;;;976      }
;;;977    }
00007a  bd70              POP      {r4-r6,pc}
                  |L33.124|
00007c  2a0d              CMP      r2,#0xd               ;912
00007e  d209              BCS      |L33.148|
000080  6bc4              LDR      r4,[r0,#0x3c]         ;915
000082  1fd2              SUBS     r2,r2,#7              ;915
000084  eb020282          ADD      r2,r2,r2,LSL #2       ;917
000088  4093              LSLS     r3,r3,r2              ;917
00008a  439c              BICS     r4,r4,r3              ;919
00008c  4091              LSLS     r1,r1,r2              ;921
00008e  430c              ORRS     r4,r4,r1              ;923
000090  63c4              STR      r4,[r0,#0x3c]         ;925
000092  bd70              POP      {r4-r6,pc}
                  |L33.148|
000094  2a13              CMP      r2,#0x13              ;928
000096  d209              BCS      |L33.172|
000098  6b84              LDR      r4,[r0,#0x38]         ;931
00009a  3a0d              SUBS     r2,r2,#0xd            ;931
00009c  eb020282          ADD      r2,r2,r2,LSL #2       ;933
0000a0  4093              LSLS     r3,r3,r2              ;933
0000a2  439c              BICS     r4,r4,r3              ;935
0000a4  4091              LSLS     r1,r1,r2              ;937
0000a6  430c              ORRS     r4,r4,r1              ;939
0000a8  6384              STR      r4,[r0,#0x38]         ;941
0000aa  bd70              POP      {r4-r6,pc}
                  |L33.172|
0000ac  2a19              CMP      r2,#0x19              ;945
0000ae  d209              BCS      |L33.196|
0000b0  6b44              LDR      r4,[r0,#0x34]         ;948
0000b2  3a13              SUBS     r2,r2,#0x13           ;948
0000b4  eb020282          ADD      r2,r2,r2,LSL #2       ;950
0000b8  4093              LSLS     r3,r3,r2              ;950
0000ba  439c              BICS     r4,r4,r3              ;952
0000bc  4091              LSLS     r1,r1,r2              ;954
0000be  430c              ORRS     r4,r4,r1              ;956
0000c0  6344              STR      r4,[r0,#0x34]         ;958
0000c2  bd70              POP      {r4-r6,pc}
                  |L33.196|
0000c4  6b04              LDR      r4,[r0,#0x30]         ;965
0000c6  3a19              SUBS     r2,r2,#0x19           ;965
0000c8  eb020282          ADD      r2,r2,r2,LSL #2       ;967
0000cc  4093              LSLS     r3,r3,r2              ;967
0000ce  439c              BICS     r4,r4,r3              ;969
0000d0  4091              LSLS     r1,r1,r2              ;971
0000d2  430c              ORRS     r4,r4,r1              ;973
0000d4  6304              STR      r4,[r0,#0x30]         ;975
0000d6  bd70              POP      {r4-r6,pc}
;;;978    
                          ENDP


                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetInjectedOffset PROC
;;;1442     */
;;;1443   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000000  b508              PUSH     {r3,lr}
;;;1444   {
;;;1445     __IO uint32_t tmp = 0;
;;;1446     
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1449     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1450     assert_param(IS_ADC_OFFSET(Offset));  
;;;1451     
;;;1452     tmp = (uint32_t)ADCx;
;;;1453     tmp += ADC_InjectedChannel;
000002  4408              ADD      r0,r0,r1
;;;1454     
;;;1455     /* Set the selected injected channel data offset */
;;;1456     *(__IO uint32_t *) tmp = (uint32_t)Offset;
000004  9000              STR      r0,[sp,#0]
000006  6002              STR      r2,[r0,#0]
;;;1457   }
000008  bd08              POP      {r3,pc}
;;;1458   
                          ENDP


                          AREA ||i.ADC_SoftwareStartConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConv PROC
;;;983      */
;;;984    void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;985    {
;;;986      /* Check the parameters */
;;;987      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;988    
;;;989      /* Enable the selected ADC conversion for regular group */
;;;990      ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
000002  f0414180          ORR      r1,r1,#0x40000000
000006  6081              STR      r1,[r0,#8]
;;;991    }
000008  4770              BX       lr
;;;992    
                          ENDP


                          AREA ||i.ADC_SoftwareStartInjectedConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartInjectedConv PROC
;;;1533     */
;;;1534   void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;1535   {
;;;1536     /* Check the parameters */
;;;1537     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1538     /* Enable the selected ADC conversion for injected group */
;;;1539     ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
000002  f4410180          ORR      r1,r1,#0x400000
000006  6081              STR      r1,[r0,#8]
;;;1540   }
000008  4770              BX       lr
;;;1541   
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;282      */
;;;283    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)                            
000000  2100              MOVS     r1,#0
;;;284    {
;;;285      /* Reset ADC init structure parameters values */
;;;286      /* Initialize the ADC_Resolution member */
;;;287      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
;;;288    
;;;289      /* Initialize the ADC_ScanConvMode member */
;;;290      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000002  6001              STR      r1,[r0,#0]
000004  7101              STRB     r1,[r0,#4]
;;;291    
;;;292      /* Initialize the ADC_ContinuousConvMode member */
;;;293      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;294    
;;;295      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;296      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;297    
;;;298      /* Initialize the ADC_ExternalTrigConv member */
;;;299      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
000008  f04f7240          MOV      r2,#0x3000000
00000c  e9c01202          STRD     r1,r2,[r0,#8]
;;;300    
;;;301      /* Initialize the ADC_DataAlign member */
;;;302      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
;;;303    
;;;304      /* Initialize the ADC_NbrOfConversion member */
;;;305      ADC_InitStruct->ADC_NbrOfConversion = 1;
000010  6101              STR      r1,[r0,#0x10]
000012  2101              MOVS     r1,#1
000014  7501              STRB     r1,[r0,#0x14]
;;;306    }
000016  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;703      */
;;;704    void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
000000  4905              LDR      r1,|L38.24|
;;;705    {
;;;706      /* Check the parameters */
;;;707      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;708    
;;;709      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;710      {
;;;711        /* Enable the temperature sensor and Vrefint channel*/
;;;712        ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Disable the temperature sensor and Vrefint channel*/
;;;717        ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L38.14|
000008  f4400000          ORR      r0,r0,#0x800000       ;712
00000c  e001              B        |L38.18|
                  |L38.14|
00000e  f4200000          BIC      r0,r0,#0x800000
                  |L38.18|
000012  6008              STR      r0,[r1,#0]            ;712
;;;718      }
;;;719    }
000014  4770              BX       lr
;;;720    
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      0x40012704

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_adc_c_e11a2ea2____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_adc_c_e11a2ea2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_adc_c_e11a2ea2____REVSH|
#line 144
|__asm___15_stm32l1xx_adc_c_e11a2ea2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
