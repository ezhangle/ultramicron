; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152d-eval\usb_endp.o --asm_dir=.\STM32L152D-EVAL\ --list_dir=.\STM32L152D-EVAL\ --depend=.\stm32l152d-eval\usb_endp.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152D_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DSTM32L1XX_HD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_HD -DUSE_STM32L152D_EVAL ..\src\usb_endp.c]
                          THUMB

                          AREA ||i.EP1_IN_Callback||, CODE, READONLY, ALIGN=2

                  EP1_IN_Callback PROC
;;;60     *******************************************************************************/
;;;61     void EP1_IN_Callback (void)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
;;;63       uint16_t USB_Tx_ptr;
;;;64       uint16_t USB_Tx_length;
;;;65       
;;;66       if (USB_Tx_State == 1)
000002  4814              LDR      r0,|L1.84|
000004  7801              LDRB     r1,[r0,#0]  ; USB_Tx_State
000006  2901              CMP      r1,#1
000008  d10f              BNE      |L1.42|
;;;67       {
;;;68         if (USART_Rx_length == 0) 
00000a  4c13              LDR      r4,|L1.88|
00000c  2600              MOVS     r6,#0
00000e  6823              LDR      r3,[r4,#0]  ; USART_Rx_length
000010  b153              CBZ      r3,|L1.40|
;;;69         {
;;;70           USB_Tx_State = 0;
;;;71         }
;;;72         else 
;;;73         {
;;;74           if (USART_Rx_length > VIRTUAL_COM_PORT_DATA_SIZE){
;;;75             USB_Tx_ptr = USART_Rx_ptr_out;
000012  4912              LDR      r1,|L1.92|
000014  2b40              CMP      r3,#0x40              ;74
000016  6808              LDR      r0,[r1,#0]            ;74
;;;76             USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
;;;77             
;;;78             USART_Rx_ptr_out += VIRTUAL_COM_PORT_DATA_SIZE;
;;;79             USART_Rx_length -= VIRTUAL_COM_PORT_DATA_SIZE;    
;;;80           }
;;;81           else 
;;;82           {
;;;83             USB_Tx_ptr = USART_Rx_ptr_out;
000018  b282              UXTH     r2,r0
00001a  d907              BLS      |L1.44|
00001c  3040              ADDS     r0,r0,#0x40           ;76
00001e  2540              MOVS     r5,#0x40              ;76
000020  3b40              SUBS     r3,r3,#0x40           ;78
000022  6008              STR      r0,[r1,#0]            ;79  ; USART_Rx_ptr_out
000024  6023              STR      r3,[r4,#0]            ;79  ; USART_Rx_length
000026  e005              B        |L1.52|
                  |L1.40|
000028  7006              STRB     r6,[r0,#0]            ;70
                  |L1.42|
;;;84             USB_Tx_length = USART_Rx_length;
;;;85             
;;;86             USART_Rx_ptr_out += USART_Rx_length;
;;;87             USART_Rx_length = 0;
;;;88           }
;;;89           UserToPMABufferCopy(&USART_Rx_Buffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
;;;90           SetEPTxCount(ENDP1, USB_Tx_length);
;;;91           SetEPTxValid(ENDP1); 
;;;92         }
;;;93       }
;;;94     }
00002a  bd70              POP      {r4-r6,pc}
                  |L1.44|
00002c  4418              ADD      r0,r0,r3              ;86
00002e  6008              STR      r0,[r1,#0]            ;87  ; USART_Rx_ptr_out
000030  b29d              UXTH     r5,r3                 ;84
000032  6026              STR      r6,[r4,#0]            ;87  ; USART_Rx_length
                  |L1.52|
000034  480a              LDR      r0,|L1.96|
000036  21c0              MOVS     r1,#0xc0              ;89
000038  4410              ADD      r0,r0,r2              ;89
00003a  462a              MOV      r2,r5                 ;89
00003c  f7fffffe          BL       UserToPMABufferCopy
000040  4629              MOV      r1,r5                 ;90
000042  2001              MOVS     r0,#1                 ;90
000044  f7fffffe          BL       SetEPTxCount
000048  e8bd4070          POP      {r4-r6,lr}            ;91
00004c  2001              MOVS     r0,#1                 ;91
00004e  f7ffbffe          B.W      SetEPTxValid
;;;95     
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      USB_Tx_State
                  |L1.88|
                          DCD      USART_Rx_length
                  |L1.92|
                          DCD      USART_Rx_ptr_out
                  |L1.96|
                          DCD      USART_Rx_Buffer

                          AREA ||i.EP3_OUT_Callback||, CODE, READONLY, ALIGN=2

                  EP3_OUT_Callback PROC
;;;102    *******************************************************************************/
;;;103    void EP3_OUT_Callback(void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105      uint16_t USB_Rx_Cnt;
;;;106      
;;;107      /* Get the received data buffer and update the counter */
;;;108      USB_Rx_Cnt = USB_SIL_Read(EP3_OUT, USB_Rx_Buffer);
000002  4906              LDR      r1,|L2.28|
000004  2003              MOVS     r0,#3
000006  f7fffffe          BL       USB_SIL_Read
;;;109      
;;;110      /* USB data will be immediately processed, this allow next USB traffic being 
;;;111      NAKed till the end of the USART Xfer */
;;;112      
;;;113      USB_To_USART_Send_Data(USB_Rx_Buffer, USB_Rx_Cnt);
00000a  b2c1              UXTB     r1,r0
00000c  4803              LDR      r0,|L2.28|
00000e  f7fffffe          BL       USB_To_USART_Send_Data
;;;114     
;;;115      /* Enable the receive of data on EP3 */
;;;116      SetEPRxValid(ENDP3);
000012  e8bd4010          POP      {r4,lr}
000016  2003              MOVS     r0,#3
000018  f7ffbffe          B.W      SetEPRxValid
;;;117    }
;;;118    
                          ENDP

                  |L2.28|
                          DCD      ||.bss||

                          AREA ||i.SOF_Callback||, CODE, READONLY, ALIGN=2

                  SOF_Callback PROC
;;;126    *******************************************************************************/
;;;127    void SOF_Callback(void)
000000  4807              LDR      r0,|L3.32|
;;;128    {
;;;129      static uint32_t FrameCount = 0;
;;;130      
;;;131      if(bDeviceState == CONFIGURED)
000002  6800              LDR      r0,[r0,#0]  ; bDeviceState
000004  2805              CMP      r0,#5
000006  d109              BNE      |L3.28|
;;;132      {
;;;133        if (FrameCount++ == VCOMPORT_IN_FRAME_INTERVAL)
000008  4806              LDR      r0,|L3.36|
00000a  6801              LDR      r1,[r0,#0]  ; FrameCount
00000c  1c49              ADDS     r1,r1,#1
00000e  6001              STR      r1,[r0,#0]  ; FrameCount
000010  2906              CMP      r1,#6
000012  d103              BNE      |L3.28|
;;;134        {
;;;135          /* Reset the frame counter */
;;;136          FrameCount = 0;
000014  2100              MOVS     r1,#0
;;;137          
;;;138          /* Check the data to be sent through IN pipe */
;;;139          Handle_USBAsynchXfer();
000016  6001              STR      r1,[r0,#0]  ; FrameCount
000018  f7ffbffe          B.W      Handle_USBAsynchXfer
                  |L3.28|
;;;140        }
;;;141      }  
;;;142    }
00001c  4770              BX       lr
;;;143    /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      bDeviceState
                  |L3.36|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USB_Rx_Buffer
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  FrameCount
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_endp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_endp_c_f894ab9c____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_endp_c_f894ab9c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_endp_c_f894ab9c____REVSH|
#line 144
|__asm___10_usb_endp_c_f894ab9c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
