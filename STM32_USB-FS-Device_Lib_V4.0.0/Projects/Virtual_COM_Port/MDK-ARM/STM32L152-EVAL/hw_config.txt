; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\hw_config.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;171    *******************************************************************************/
;;;172    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L1.8|
;;;173    {
;;;174      /* Set the device state to suspend */
;;;175      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;176    }
000006  4770              BX       lr
;;;177    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;515    *******************************************************************************/
;;;516    void Get_SerialNum(void)
000000  4809              LDR      r0,|L2.40|
;;;517    {
000002  b510              PUSH     {r4,lr}
;;;518      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;519    
;;;520      Device_Serial0 = *(uint32_t*)ID1;
000004  e9d01414          LDRD     r1,r4,[r0,#0x50]
;;;521      Device_Serial1 = *(uint32_t*)ID2;
;;;522      Device_Serial2 = *(uint32_t*)ID3;  
000008  6e40              LDR      r0,[r0,#0x64]
;;;523    
;;;524      Device_Serial0 += Device_Serial2;
00000a  1808              ADDS     r0,r1,r0
00000c  d00b              BEQ      |L2.38|
;;;525    
;;;526      if (Device_Serial0 != 0)
;;;527      {
;;;528        IntToUnicode (Device_Serial0, &Virtual_Com_Port_StringSerial[2] , 8);
00000e  2208              MOVS     r2,#8
000010  4906              LDR      r1,|L2.44|
000012  f7fffffe          BL       IntToUnicode
;;;529        IntToUnicode (Device_Serial1, &Virtual_Com_Port_StringSerial[18], 4);
000016  4905              LDR      r1,|L2.44|
000018  4620              MOV      r0,r4
00001a  2204              MOVS     r2,#4
00001c  e8bd4010          POP      {r4,lr}
000020  3110              ADDS     r1,r1,#0x10
000022  f7ffbffe          B.W      IntToUnicode
                  |L2.38|
;;;530      }
;;;531    }
000026  bd10              POP      {r4,pc}
;;;532    
                          ENDP

                  |L2.40|
                          DCD      0x1ff80000
                  |L2.44|
                          DCD      Virtual_Com_Port_StringSerial+0x2

                          AREA ||i.Handle_USBAsynchXfer||, CODE, READONLY, ALIGN=2

                  Handle_USBAsynchXfer PROC
;;;430    *******************************************************************************/
;;;431    void Handle_USBAsynchXfer (void)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
;;;433      
;;;434      uint16_t USB_Tx_ptr;
;;;435      uint16_t USB_Tx_length;
;;;436      
;;;437      if(USB_Tx_State != 1)
000002  481b              LDR      r0,|L3.112|
000004  7801              LDRB     r1,[r0,#0]  ; USB_Tx_State
000006  2901              CMP      r1,#1
000008  d00a              BEQ      |L3.32|
;;;438      {
;;;439        if (USART_Rx_ptr_out == USART_RX_DATA_SIZE)
00000a  6882              LDR      r2,[r0,#8]  ; USART_Rx_ptr_out
00000c  2100              MOVS     r1,#0
00000e  f5b26f00          CMP      r2,#0x800
000012  d100              BNE      |L3.22|
;;;440        {
;;;441          USART_Rx_ptr_out = 0;
000014  6081              STR      r1,[r0,#8]  ; USART_Rx_ptr_out
                  |L3.22|
000016  e9d02301          LDRD     r2,r3,[r0,#4]
;;;442        }
;;;443        
;;;444        if(USART_Rx_ptr_out == USART_Rx_ptr_in) 
00001a  4293              CMP      r3,r2
00001c  d101              BNE      |L3.34|
;;;445        {
;;;446          USB_Tx_State = 0; 
00001e  7001              STRB     r1,[r0,#0]
                  |L3.32|
;;;447          return;
;;;448        }
;;;449        
;;;450        if(USART_Rx_ptr_out > USART_Rx_ptr_in) /* rollback */
;;;451        { 
;;;452          USART_Rx_length = USART_RX_DATA_SIZE - USART_Rx_ptr_out;
;;;453        }
;;;454        else 
;;;455        {
;;;456          USART_Rx_length = USART_Rx_ptr_in - USART_Rx_ptr_out;
;;;457        }
;;;458        
;;;459        if (USART_Rx_length > VIRTUAL_COM_PORT_DATA_SIZE)
;;;460        {
;;;461          USB_Tx_ptr = USART_Rx_ptr_out;
;;;462          USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
;;;463          
;;;464          USART_Rx_ptr_out += VIRTUAL_COM_PORT_DATA_SIZE;	
;;;465          USART_Rx_length -= VIRTUAL_COM_PORT_DATA_SIZE;	
;;;466        }
;;;467        else
;;;468        {
;;;469          USB_Tx_ptr = USART_Rx_ptr_out;
;;;470          USB_Tx_length = USART_Rx_length;
;;;471          
;;;472          USART_Rx_ptr_out += USART_Rx_length;
;;;473          USART_Rx_length = 0;
;;;474        }
;;;475        USB_Tx_State = 1; 
;;;476        UserToPMABufferCopy(&USART_Rx_Buffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
;;;477        SetEPTxCount(ENDP1, USB_Tx_length);
;;;478        SetEPTxValid(ENDP1); 
;;;479      }  
;;;480      
;;;481    }
000020  bd70              POP      {r4-r6,pc}
                  |L3.34|
000022  d902              BLS      |L3.42|
000024  f5c36200          RSB      r2,r3,#0x800          ;452
000028  e001              B        |L3.46|
                  |L3.42|
00002a  eba20203          SUB      r2,r2,r3              ;456
                  |L3.46|
00002e  4614              MOV      r4,r2                 ;459
000030  60c2              STR      r2,[r0,#0xc]          ;459  ; USART_Rx_length
000032  2a40              CMP      r2,#0x40              ;459
000034  b29a              UXTH     r2,r3                 ;469
000036  d905              BLS      |L3.68|
000038  2540              MOVS     r5,#0x40              ;462
00003a  3340              ADDS     r3,r3,#0x40           ;462
00003c  3c40              SUBS     r4,r4,#0x40           ;462
00003e  e9c03402          STRD     r3,r4,[r0,#8]         ;462
000042  e003              B        |L3.76|
                  |L3.68|
000044  4423              ADD      r3,r3,r4              ;472
000046  e9c03102          STRD     r3,r1,[r0,#8]         ;472
00004a  b2a5              UXTH     r5,r4                 ;470
                  |L3.76|
00004c  2101              MOVS     r1,#1                 ;475
00004e  7001              STRB     r1,[r0,#0]            ;475
000050  4808              LDR      r0,|L3.116|
000052  21c0              MOVS     r1,#0xc0              ;476
000054  4410              ADD      r0,r0,r2              ;476
000056  462a              MOV      r2,r5                 ;476
000058  f7fffffe          BL       UserToPMABufferCopy
00005c  4629              MOV      r1,r5                 ;477
00005e  2001              MOVS     r0,#1                 ;477
000060  f7fffffe          BL       SetEPTxCount
000064  e8bd4070          POP      {r4-r6,lr}            ;478
000068  2001              MOVS     r0,#1                 ;478
00006a  f7ffbffe          B.W      SetEPTxValid
;;;482    /*******************************************************************************
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
                          DCD      ||.data||
                  |L3.116|
                          DCD      ||.bss||+0x10

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;539    *******************************************************************************/
;;;540    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;541    {
;;;542      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;543      
;;;544      for( idx = 0 ; idx < len ; idx ++)
;;;545      {
;;;546        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;547        {
;;;548          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;549        }
;;;550        else
;;;551        {
;;;552          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L4.50|
00000e  bf00              NOP                            ;546
                  |L4.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;546
000014  d902              BLS      |L4.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;548
00001a  e001              B        |L4.32|
                  |L4.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L4.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;553        }
;;;554        
;;;555        value = value << 4;
;;;556        
;;;557        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;555
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;544
                  |L4.50|
000032  4293              CMP      r3,r2                 ;544
000034  d3ec              BCC      |L4.16|
;;;558      }
;;;559    }
000036  bdf0              POP      {r4-r7,pc}
;;;560    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;183    *******************************************************************************/
;;;184    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L5.20|
;;;185    {
;;;186      DEVICE_INFO *pInfo = &Device_Info;
;;;187    
;;;188      /* Set the device state to the correct state */
;;;189      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;190      {
;;;191        /* Device configured */
;;;192        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L5.24|
000006  b109              CBZ      r1,|L5.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L5.14|
                  |L5.12|
;;;193      }
;;;194      else
;;;195      {
;;;196        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L5.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;197      }
;;;198      /*Enable SystemCoreClock*/
;;;199      SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;200    }
;;;201    
                          ENDP

                  |L5.20|
                          DCD      Device_Info
                  |L5.24|
                          DCD      bDeviceState

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;64     *******************************************************************************/
;;;65     void Set_System(void)
000000  b510              PUSH     {r4,lr}
;;;66     {
;;;67     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)
;;;68       GPIO_InitTypeDef GPIO_InitStructure;
;;;69     #endif /* STM32L1XX_MD && STM32L1XX_XD */  
;;;70     
;;;71     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;72       GPIO_InitTypeDef  GPIO_InitStructure;
;;;73     #endif /* USB_USE_EXTERNAL_PULLUP */ 
;;;74       
;;;75       /*!< At this stage the microcontroller clock setting is already configured, 
;;;76            this is done through SystemInit() function which is called from startup
;;;77            file (startup_stm32f10x_xx.s) before to branch to application main.
;;;78            To reconfigure the default setting of SystemInit() function, refer to
;;;79            system_stm32f10x.c file
;;;80          */   
;;;81     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;82       /* Enable the SYSCFG module clock */
;;;83       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;84     #endif /* STM32L1XX_XD */ 
;;;85        
;;;86     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS) && !defined(STM32F37X) && !defined(STM32F30X)
;;;87       /* Enable USB_DISCONNECT GPIO clock */
;;;88       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
;;;89     
;;;90       /* Configure USB pull-up pin */
;;;91       GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;92       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;93       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
;;;94       GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;95     #endif /* STM32L1XX_MD && STM32L1XX_XD */
;;;96        
;;;97     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;98       /* Enable the USB disconnect GPIO clock */
;;;99       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;100    
;;;101      /* USB_DISCONNECT used as USB pull-up */
;;;102      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;103      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;104      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;105      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;106      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;107      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;108    #endif /* USB_USE_EXTERNAL_PULLUP */ 
;;;109      
;;;110    #if defined(STM32F37X) || defined(STM32F30X)
;;;111      
;;;112      /* Enable the USB disconnect GPIO clock */
;;;113      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;114      
;;;115      /*Set PA11,12 as IN - USB_DM,DP*/
;;;116      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;117      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;118      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;119      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;120      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;121      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;122      GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;123      
;;;124      /*SET PA11,12 for USB: USB_DM,DP*/
;;;125      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;126      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;127      
;;;128      /* USB_DISCONNECT used as USB pull-up */
;;;129      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;130      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;131      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;132      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;133      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;134      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;135    #endif /* STM32F37X && STM32F30X */ 
;;;136      
;;;137      /* Configure the EXTI line 18 connected internally to the USB IP */
;;;138      EXTI_ClearITPendingBit(EXTI_Line18);
00000a  f44f2480          MOV      r4,#0x40000
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EXTI_ClearITPendingBit
;;;139      EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
000014  4905              LDR      r1,|L6.44|
;;;140      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000016  2008              MOVS     r0,#8
000018  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
00001a  7148              STRB     r0,[r1,#5]
;;;141      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  7188              STRB     r0,[r1,#6]
;;;142      EXTI_Init(&EXTI_InitStructure);
000020  e8bd4010          POP      {r4,lr}
000024  4608              MOV      r0,r1
000026  f7ffbffe          B.W      EXTI_Init
;;;143    }
;;;144    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      ||.data||+0x10

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;150    *******************************************************************************/
;;;151    void Set_USBClock(void)
000000  2101              MOVS     r1,#1
;;;152    {
;;;153    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD) || defined(STM32L1XX_MD_PLUS) 
;;;154      /* Enable USB clock */
;;;155      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000002  05c8              LSLS     r0,r1,#23
000004  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;156      
;;;157    #else 
;;;158      /* Select USBCLK source */
;;;159      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
;;;160      
;;;161      /* Enable the USB clock */
;;;162      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;163    #endif /* STM32L1XX_MD */
;;;164    }
;;;165    
                          ENDP


                          AREA ||i.USART_Config||, CODE, READONLY, ALIGN=2

                  USART_Config PROC
;;;329    *******************************************************************************/
;;;330    bool USART_Config(void)
000000  4a1e              LDR      r2,|L8.124|
;;;331    {
000002  b510              PUSH     {r4,lr}
;;;332    
;;;333      /* set the Stop bit*/
;;;334      switch (linecoding.format)
000004  7913              LDRB     r3,[r2,#4]  ; linecoding
;;;335      {
;;;336        case 0:
;;;337          USART_InitStructure.USART_StopBits = USART_StopBits_1;
000006  481e              LDR      r0,|L8.128|
000008  2100              MOVS     r1,#0                 ;334
00000a  b123              CBZ      r3,|L8.22|
00000c  2b01              CMP      r3,#1                 ;334
00000e  d004              BEQ      |L8.26|
000010  2b02              CMP      r3,#2                 ;334
000012  d11c              BNE      |L8.78|
000014  e004              B        |L8.32|
                  |L8.22|
000016  80c1              STRH     r1,[r0,#6]
;;;338          break;
000018  e005              B        |L8.38|
                  |L8.26|
;;;339        case 1:
;;;340          USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
00001a  f44f5340          MOV      r3,#0x3000
;;;341          break;
00001e  e001              B        |L8.36|
                  |L8.32|
;;;342        case 2:
;;;343          USART_InitStructure.USART_StopBits = USART_StopBits_2;
000020  f44f5300          MOV      r3,#0x2000
                  |L8.36|
000024  80c3              STRH     r3,[r0,#6]            ;340
                  |L8.38|
;;;344          break;
;;;345        default :
;;;346        {
;;;347          USART_Config_Default();
;;;348          return (FALSE);
;;;349        }
;;;350      }
;;;351    
;;;352      /* set the parity bit*/
;;;353      switch (linecoding.paritytype)
000026  7953              LDRB     r3,[r2,#5]  ; linecoding
000028  b123              CBZ      r3,|L8.52|
00002a  2b01              CMP      r3,#1
00002c  d004              BEQ      |L8.56|
00002e  2b02              CMP      r3,#2
000030  d10d              BNE      |L8.78|
000032  e004              B        |L8.62|
                  |L8.52|
;;;354      {
;;;355        case 0:
;;;356          USART_InitStructure.USART_Parity = USART_Parity_No;
000034  8101              STRH     r1,[r0,#8]
;;;357          break;
000036  e005              B        |L8.68|
                  |L8.56|
;;;358        case 1:
;;;359          USART_InitStructure.USART_Parity = USART_Parity_Even;
000038  f44f6380          MOV      r3,#0x400
;;;360          break;
00003c  e001              B        |L8.66|
                  |L8.62|
;;;361        case 2:
;;;362          USART_InitStructure.USART_Parity = USART_Parity_Odd;
00003e  f44f63c0          MOV      r3,#0x600
                  |L8.66|
000042  8103              STRH     r3,[r0,#8]            ;359
                  |L8.68|
;;;363          break;
;;;364        default :
;;;365        {
;;;366          USART_Config_Default();
;;;367          return (FALSE);
;;;368        }
;;;369      }
;;;370    
;;;371      /*set the data type : only 8bits and 9bits is supported */
;;;372      switch (linecoding.datatype)
000044  7993              LDRB     r3,[r2,#6]  ; linecoding
000046  2b07              CMP      r3,#7
000048  d00b              BEQ      |L8.98|
00004a  2b08              CMP      r3,#8
00004c  d003              BEQ      |L8.86|
                  |L8.78|
;;;373      {
;;;374        case 0x07:
;;;375          /* With this configuration a parity (Even or Odd) should be set */
;;;376          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;377          break;
;;;378        case 0x08:
;;;379          if (USART_InitStructure.USART_Parity == USART_Parity_No)
;;;380          {
;;;381            USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;382          }
;;;383          else 
;;;384          {
;;;385            USART_InitStructure.USART_WordLength = USART_WordLength_9b;
;;;386          }
;;;387          
;;;388          break;
;;;389        default :
;;;390        {
;;;391          USART_Config_Default();
00004e  f7fffffe          BL       USART_Config_Default
;;;392          return (FALSE);
000052  2000              MOVS     r0,#0
;;;393        }
;;;394      }
;;;395    
;;;396      USART_InitStructure.USART_BaudRate = linecoding.bitrate;
;;;397      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;398      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;399     
;;;400      /* Configure and enable the USART */
;;;401      STM_EVAL_COMInit(COM1, &USART_InitStructure);
;;;402    
;;;403      return (TRUE);
;;;404    }
000054  bd10              POP      {r4,pc}
                  |L8.86|
000056  8903              LDRH     r3,[r0,#8]            ;379  ; USART_InitStructure
000058  b11b              CBZ      r3,|L8.98|
00005a  f44f5380          MOV      r3,#0x1000            ;385
00005e  8083              STRH     r3,[r0,#4]            ;385
000060  e000              B        |L8.100|
                  |L8.98|
000062  8081              STRH     r1,[r0,#4]            ;381
                  |L8.100|
000064  6812              LDR      r2,[r2,#0]            ;396  ; linecoding
000066  6002              STR      r2,[r0,#0]            ;397  ; USART_InitStructure
000068  8181              STRH     r1,[r0,#0xc]          ;397
00006a  210c              MOVS     r1,#0xc               ;398
00006c  8141              STRH     r1,[r0,#0xa]          ;398
00006e  4904              LDR      r1,|L8.128|
000070  2000              MOVS     r0,#0                 ;401
000072  f7fffffe          BL       STM_EVAL_COMInit
000076  2001              MOVS     r0,#1                 ;403
000078  bd10              POP      {r4,pc}
;;;405    
                          ENDP

00007a  0000              DCW      0x0000
                  |L8.124|
                          DCD      linecoding
                  |L8.128|
                          DCD      ||.bss||

                          AREA ||i.USART_Config_Default||, CODE, READONLY, ALIGN=2

                  USART_Config_Default PROC
;;;296    *******************************************************************************/
;;;297    void USART_Config_Default(void)
000000  480c              LDR      r0,|L9.52|
;;;298    {
000002  b510              PUSH     {r4,lr}
;;;299      /* EVAL_COM1 default configuration */
;;;300      /* EVAL_COM1 configured as follow:
;;;301            - BaudRate = 9600 baud  
;;;302            - Word Length = 8 Bits
;;;303            - One Stop Bit
;;;304            - Parity Odd
;;;305            - Hardware flow control disabled
;;;306            - Receive and transmit enabled
;;;307      */
;;;308      USART_InitStructure.USART_BaudRate = 9600;
000004  f44f5116          MOV      r1,#0x2580
;;;309      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000008  6001              STR      r1,[r0,#0]  ; USART_InitStructure
00000a  2100              MOVS     r1,#0
00000c  8081              STRH     r1,[r0,#4]
;;;310      USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000e  80c1              STRH     r1,[r0,#6]
;;;311      USART_InitStructure.USART_Parity = USART_Parity_Odd;
000010  f44f62c0          MOV      r2,#0x600
000014  8102              STRH     r2,[r0,#8]
;;;312      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000016  8181              STRH     r1,[r0,#0xc]
;;;313      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  210c              MOVS     r1,#0xc
00001a  8141              STRH     r1,[r0,#0xa]
;;;314    
;;;315      /* Configure and enable the USART */
;;;316      STM_EVAL_COMInit(COM1, &USART_InitStructure);
00001c  4601              MOV      r1,r0
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       STM_EVAL_COMInit
;;;317    
;;;318      /* Enable the USART Receive interrupt */
;;;319      USART_ITConfig(EVAL_COM1, USART_IT_RXNE, ENABLE);
000024  e8bd4010          POP      {r4,lr}
000028  2201              MOVS     r2,#1
00002a  f2405125          MOV      r1,#0x525
00002e  4802              LDR      r0,|L9.56|
000030  f7ffbffe          B.W      USART_ITConfig
;;;320    }
;;;321    
                          ENDP

                  |L9.52|
                          DCD      ||.bss||
                  |L9.56|
                          DCD      0x40004400

                          AREA ||i.USART_To_USB_Send_Data||, CODE, READONLY, ALIGN=2

                  USART_To_USB_Send_Data PROC
;;;487    *******************************************************************************/
;;;488    void USART_To_USB_Send_Data(void)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
;;;490      
;;;491      if (linecoding.datatype == 7)
000002  480e              LDR      r0,|L10.60|
;;;492      {
;;;493        USART_Rx_Buffer[USART_Rx_ptr_in] = USART_ReceiveData(EVAL_COM1) & 0x7F;
000004  4d0f              LDR      r5,|L10.68|
000006  4c10              LDR      r4,|L10.72|
000008  7981              LDRB     r1,[r0,#6]            ;491  ; linecoding
00000a  480d              LDR      r0,|L10.64|
00000c  2907              CMP      r1,#7                 ;491
00000e  d002              BEQ      |L10.22|
;;;494      }
;;;495      else if (linecoding.datatype == 8)
000010  2908              CMP      r1,#8
000012  d005              BEQ      |L10.32|
000014  e008              B        |L10.40|
                  |L10.22|
000016  f7fffffe          BL       USART_ReceiveData
00001a  f000007f          AND      r0,r0,#0x7f           ;493
00001e  e001              B        |L10.36|
                  |L10.32|
;;;496      {
;;;497        USART_Rx_Buffer[USART_Rx_ptr_in] = USART_ReceiveData(EVAL_COM1);
000020  f7fffffe          BL       USART_ReceiveData
                  |L10.36|
000024  6861              LDR      r1,[r4,#4]  ; USART_Rx_ptr_in
000026  5468              STRB     r0,[r5,r1]
                  |L10.40|
;;;498      }
;;;499      
;;;500      USART_Rx_ptr_in++;
000028  6860              LDR      r0,[r4,#4]  ; USART_Rx_ptr_in
00002a  1c40              ADDS     r0,r0,#1
;;;501      
;;;502      /* To avoid buffer overflow */
;;;503      if(USART_Rx_ptr_in == USART_RX_DATA_SIZE)
00002c  6060              STR      r0,[r4,#4]  ; USART_Rx_ptr_in
00002e  f5b06f00          CMP      r0,#0x800
000032  d101              BNE      |L10.56|
;;;504      {
;;;505        USART_Rx_ptr_in = 0;
000034  2000              MOVS     r0,#0
000036  6060              STR      r0,[r4,#4]  ; USART_Rx_ptr_in
                  |L10.56|
;;;506      }
;;;507    }
000038  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

00003a  0000              DCW      0x0000
                  |L10.60|
                          DCD      linecoding
                  |L10.64|
                          DCD      0x40004400
                  |L10.68|
                          DCD      ||.bss||+0x10
                  |L10.72|
                          DCD      ||.data||

                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=1

                  USB_Cable_Config PROC
;;;266    *******************************************************************************/
;;;267    void USB_Cable_Config (FunctionalState NewState)
000000  b100              CBZ      r0,|L11.4|
;;;268    {
;;;269    #if defined(STM32L1XX_MD) || defined (STM32L1XX_HD)|| (STM32L1XX_MD_PLUS)
;;;270      if (NewState != DISABLE)
;;;271      {
;;;272        STM32L15_USB_CONNECT;
000002  2001              MOVS     r0,#1
                  |L11.4|
;;;273      }
;;;274      else
;;;275      {
;;;276        STM32L15_USB_DISCONNECT;
000004  f7ffbffe          B.W      SYSCFG_USBPuCmd
;;;277      }  
;;;278      
;;;279    #else /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
;;;280      if (NewState != DISABLE)
;;;281      {
;;;282        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;283      }
;;;284      else
;;;285      {
;;;286        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;287      }
;;;288    #endif /* STM32L1XX_MD */
;;;289    }
;;;290    
                          ENDP


                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;207    *******************************************************************************/
;;;208    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;209    {
;;;210      NVIC_InitTypeDef NVIC_InitStructure; 
;;;211      
;;;212      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;213      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;214      
;;;215    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;216      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;217      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;218      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2500              MOVS     r5,#0
000018  f88d5002          STRB     r5,[sp,#2]
;;;219      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2401              MOVS     r4,#1
00001e  f88d4003          STRB     r4,[sp,#3]
;;;220      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;221      
;;;222        /* Enable the USB Wake-up interrupt */
;;;223      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;224      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d5001          STRB     r5,[sp,#1]
;;;225      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d4003          STRB     r4,[sp,#3]
;;;226      NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;227      
;;;228    #elif defined(STM32F37X)
;;;229      /* Enable the USB interrupt */
;;;230      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;231      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;232      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;233      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;234      NVIC_Init(&NVIC_InitStructure);
;;;235      
;;;236      /* Enable the USB Wake-up interrupt */
;;;237      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;238      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;239      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;240      NVIC_Init(&NVIC_InitStructure);
;;;241      
;;;242    #else
;;;243      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
;;;244      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;245      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;246      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;247      NVIC_Init(&NVIC_InitStructure);
;;;248      
;;;249        /* Enable the USB Wake-up interrupt */
;;;250      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;251      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;252      NVIC_Init(&NVIC_InitStructure);
;;;253    #endif /* STM32L1XX_XD */
;;;254    
;;;255      /* Enable USART Interrupt */
;;;256      NVIC_InitStructure.NVIC_IRQChannel = EVAL_COM1_IRQn;
00003c  2026              MOVS     r0,#0x26
00003e  f88d0000          STRB     r0,[sp,#0]
;;;257      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000042  f88d4001          STRB     r4,[sp,#1]
;;;258      NVIC_Init(&NVIC_InitStructure);
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       NVIC_Init
;;;259    }
00004c  bd38              POP      {r3-r5,pc}
;;;260    
                          ENDP


                          AREA ||i.USB_To_USART_Send_Data||, CODE, READONLY, ALIGN=2

                  USB_To_USART_Send_Data PROC
;;;412    *******************************************************************************/
;;;413    void USB_To_USART_Send_Data(uint8_t* data_buffer, uint8_t Nb_bytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;414    {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;415      
;;;416      uint32_t i;
;;;417      
;;;418      for (i = 0; i < Nb_bytes; i++)
000008  2400              MOVS     r4,#0
;;;419      {
;;;420        USART_SendData(EVAL_COM1, *(data_buffer + i));
00000a  4d08              LDR      r5,|L13.44|
00000c  e00a              B        |L13.36|
                  |L13.14|
00000e  5d39              LDRB     r1,[r7,r4]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       USART_SendData
                  |L13.22|
;;;421        while(USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TXE) == RESET); 
000016  2180              MOVS     r1,#0x80
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       USART_GetFlagStatus
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L13.22|
000022  1c64              ADDS     r4,r4,#1
                  |L13.36|
000024  42b4              CMP      r4,r6                 ;418
000026  d3f2              BCC      |L13.14|
;;;422      }  
;;;423    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;424    
                          ENDP

                  |L13.44|
                          DCD      0x40004400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16
                  USART_Rx_Buffer
                          %        2048

                          AREA ||.data||, DATA, ALIGN=2

                  USB_Tx_State
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  USART_Rx_ptr_in
                          DCD      0x00000000
                  USART_Rx_ptr_out
                          DCD      0x00000000
                  USART_Rx_length
                          DCD      0x00000000
                  EXTI_InitStructure
                          %        8

                          AREA ||area_number.18||, DATA, ALIGN=0

                          EXPORTAS ||area_number.18||, ||.data||
                  HSEStartUpStatus
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_489be4a8____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_489be4a8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_489be4a8____REVSH|
#line 144
|__asm___11_hw_config_c_489be4a8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
