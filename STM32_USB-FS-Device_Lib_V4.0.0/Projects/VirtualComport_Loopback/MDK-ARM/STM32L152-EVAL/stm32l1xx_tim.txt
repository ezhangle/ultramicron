; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_tim.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_tim.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;2696     */
;;;2697   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;2698                          uint16_t TIM_ICFilter)
;;;2699   {
;;;2700     uint16_t tmpccmr1 = 0, tmpccer = 0;
;;;2701     
;;;2702     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2703     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  8404              STRH     r4,[r0,#0x20]
;;;2704     tmpccmr1 = TIMx->CCMR1;
00000a  8b05              LDRH     r5,[r0,#0x18]
;;;2705     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;2706     /* Select the Input and set the filter */
;;;2707     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
;;;2708     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00000e  f64f76ff          MOV      r6,#0xffff
000012  ea061303          AND      r3,r6,r3,LSL #4
000016  4313              ORRS     r3,r3,r2
000018  f02505f3          BIC      r5,r5,#0xf3           ;2707
00001c  432b              ORRS     r3,r3,r5
;;;2709     /* Select the Polarity and set the CC1E Bit */
;;;2710     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
00001e  f024020a          BIC      r2,r4,#0xa
;;;2711     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000022  430a              ORRS     r2,r2,r1
000024  f0420101          ORR      r1,r2,#1
;;;2712     /* Write to TIMx CCMR1 and CCER registers */
;;;2713     TIMx->CCMR1 = tmpccmr1;
000028  8303              STRH     r3,[r0,#0x18]
;;;2714     TIMx->CCER = tmpccer;
00002a  8401              STRH     r1,[r0,#0x20]
;;;2715   }
00002c  bd70              POP      {r4-r6,pc}
;;;2716   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;2732     */
;;;2733   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2734                          uint16_t TIM_ICFilter)
;;;2735   {
;;;2736     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;2737     
;;;2738     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2739     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  8404              STRH     r4,[r0,#0x20]
;;;2740     tmpccmr1 = TIMx->CCMR1;
00000a  8b07              LDRH     r7,[r0,#0x18]
;;;2741     tmpccer = TIMx->CCER;
00000c  8c06              LDRH     r6,[r0,#0x20]
;;;2742     tmp = (uint16_t)(TIM_ICPolarity << 4);
00000e  f64f74ff          MOV      r4,#0xffff
000012  ea041501          AND      r5,r4,r1,LSL #4
;;;2743     /* Select the Input and set the filter */
;;;2744     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
000016  f4274773          BIC      r7,r7,#0xf300
;;;2745     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00001a  ea043103          AND      r1,r4,r3,LSL #12
00001e  4339              ORRS     r1,r1,r7
;;;2746     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000020  ea042202          AND      r2,r4,r2,LSL #8
000024  430a              ORRS     r2,r2,r1
;;;2747     /* Select the Polarity and set the CC2E Bit */
;;;2748     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
000026  f02601a0          BIC      r1,r6,#0xa0
;;;2749     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
00002a  4329              ORRS     r1,r1,r5
00002c  f0410110          ORR      r1,r1,#0x10
;;;2750     /* Write to TIMx CCMR1 and CCER registers */
;;;2751     TIMx->CCMR1 = tmpccmr1 ;
000030  8302              STRH     r2,[r0,#0x18]
;;;2752     TIMx->CCER = tmpccer;
000032  8401              STRH     r1,[r0,#0x20]
;;;2753   }
000034  bdf0              POP      {r4-r7,pc}
;;;2754   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;470      */
;;;471    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;472    {
;;;473      /* Check the parameters */
;;;474      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;475      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;476      
;;;477      if (NewState != DISABLE)
;;;478      {
;;;479        /* Set the ARR Preload Bit */
;;;480        TIMx->CR1 |= TIM_CR1_ARPE;
;;;481      }
;;;482      else
;;;483      {
;;;484        /* Reset the ARR Preload Bit */
;;;485        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410180          ORR      r1,r1,#0x80           ;480
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;480
;;;486      }
;;;487    }
000012  4770              BX       lr
;;;488    
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1499     */
;;;1500   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;1501   {
;;;1502     uint16_t tmp = 0;
;;;1503   
;;;1504     /* Check the parameters */
;;;1505     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1506     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1507   
;;;1508     tmp = CCER_CCE_SET << TIM_Channel;
000002  2301              MOVS     r3,#1
;;;1509   
;;;1510     /* Reset the CCxE Bit */
;;;1511     TIMx->CCER &= (uint16_t)~ tmp;
000004  8c04              LDRH     r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1508
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;1512   
;;;1513     /* Set or reset the CCxE Bit */ 
;;;1514     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;1515   }
000014  bd10              POP      {r4,pc}
;;;1516   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;1990     */
;;;1991   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;1992   {  
;;;1993     /* Check the parameters */
;;;1994     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1995     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;1996      
;;;1997     /* Clear the flags */
;;;1998     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8201              STRH     r1,[r0,#0x10]
;;;1999   }
000004  4770              BX       lr
;;;2000   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2061     */
;;;2062   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;2063   {
;;;2064     /* Check the parameters */
;;;2065     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2066     assert_param(IS_TIM_IT(TIM_IT));
;;;2067      
;;;2068     /* Clear the IT pending Bit */
;;;2069     TIMx->SR = (uint16_t)~TIM_IT;
000002  8201              STRH     r1,[r0,#0x10]
;;;2070   }
000004  4770              BX       lr
;;;2071   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1270     */
;;;1271   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1272   {
;;;1273     uint16_t tmpccmr1 = 0;
;;;1274     
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1277     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1278     
;;;1279     tmpccmr1 = TIMx->CCMR1;
;;;1280     /* Reset the OC1CE Bit */
;;;1281     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1282     /* Enable or Disable the Output Compare Clear Bit */
;;;1283     tmpccmr1 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1284     /* Write to TIMx CCMR1 register */
;;;1285     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1286   }
00000a  4770              BX       lr
;;;1287   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1297     */
;;;1298   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1299   {
;;;1300     uint16_t tmpccmr1 = 0;
;;;1301     
;;;1302     /* Check the parameters */
;;;1303     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1304     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1305     
;;;1306     tmpccmr1 = TIMx->CCMR1;
;;;1307     /* Reset the OC2CE Bit */
;;;1308     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
;;;1309     /* Enable or Disable the Output Compare Clear Bit */
;;;1310     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1308
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1311     /* Write to TIMx CCMR1 register */
;;;1312     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1313   }
000012  4770              BX       lr
;;;1314   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1323     */
;;;1324   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1325   {
;;;1326     uint16_t tmpccmr2 = 0;
;;;1327     
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1330     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1331     
;;;1332     tmpccmr2 = TIMx->CCMR2;
;;;1333     /* Reset the OC3CE Bit */
;;;1334     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1335     /* Enable or Disable the Output Compare Clear Bit */
;;;1336     tmpccmr2 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1337     /* Write to TIMx CCMR2 register */
;;;1338     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1339   }
00000a  4770              BX       lr
;;;1340   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1349     */
;;;1350   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1351   {
;;;1352     uint16_t tmpccmr2 = 0;
;;;1353     
;;;1354     /* Check the parameters */
;;;1355     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1356     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1357     
;;;1358     tmpccmr2 = TIMx->CCMR2;
;;;1359     /* Reset the OC4CE Bit */
;;;1360     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
;;;1361     /* Enable or Disable the Output Compare Clear Bit */
;;;1362     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1360
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1363     /* Write to TIMx CCMR2 register */
;;;1364     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1365   }
000012  4770              BX       lr
;;;1366   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;540      */
;;;541    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;542    {
;;;543      /* Check the parameters */
;;;544      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;545      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;546      
;;;547      if (NewState != DISABLE)
;;;548      {
;;;549        /* Enable the TIM Counter */
;;;550        TIMx->CR1 |= TIM_CR1_CEN;
;;;551      }
;;;552      else
;;;553      {
;;;554        /* Disable the TIM Counter */
;;;555        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L11.12|
000006  f0410101          ORR      r1,r1,#1              ;550
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L11.16|
000010  8001              STRH     r1,[r0,#0]            ;550
;;;556      }
;;;557    }
000012  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;334      */
;;;335    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;336    {
;;;337      uint16_t tmpcr1 = 0;
;;;338      
;;;339      /* Check the parameters */
;;;340      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;341      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;342      
;;;343      tmpcr1 = TIMx->CR1;
;;;344      /* Reset the CMS and DIR Bits */
;;;345      tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000002  f0220270          BIC      r2,r2,#0x70
;;;346      /* Set the Counter Mode */
;;;347      tmpcr1 |= TIM_CounterMode;
000006  430a              ORRS     r2,r2,r1
;;;348      /* Write to TIMx CR1 register */
;;;349      TIMx->CR1 = tmpcr1;
000008  8002              STRH     r2,[r0,#0]
;;;350    }
00000a  4770              BX       lr
;;;351    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2124     */
;;;2125   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2126   { 
;;;2127     /* Check the parameters */
;;;2128     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2129     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2130     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2131     
;;;2132     if (NewState != DISABLE)
;;;2133     {
;;;2134       /* Enable the DMA sources */
;;;2135       TIMx->DIER |= TIM_DMASource; 
;;;2136     }
;;;2137     else
;;;2138     {
;;;2139       /* Disable the DMA sources */
;;;2140       TIMx->DIER &= (uint16_t)~TIM_DMASource;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L13.10|
000006  430a              ORRS     r2,r2,r1              ;2135
000008  e000              B        |L13.12|
                  |L13.10|
00000a  438a              BICS     r2,r2,r1
                  |L13.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;2135
;;;2141     }
;;;2142   }
00000e  4770              BX       lr
;;;2143   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2099     */
;;;2100   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;2101   {
;;;2102     /* Check the parameters */
;;;2103     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2104     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2105     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2106     /* Set the DMA Base and the DMA Burst Length */
;;;2107     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;2108   }
000006  4770              BX       lr
;;;2109   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;182      */
;;;183    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185      /* Check the parameters */
;;;186      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;187       
;;;188      if (TIMx == TIM2)
000002  f1b04f80          CMP      r0,#0x40000000
000006  d009              BEQ      |L15.28|
;;;189      {
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;192      }
;;;193      else if (TIMx == TIM3)
000008  492e              LDR      r1,|L15.196|
00000a  4288              CMP      r0,r1
00000c  d10d              BNE      |L15.42|
;;;194      {
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00000e  2101              MOVS     r1,#1
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000016  2100              MOVS     r1,#0
000018  2002              MOVS     r0,#2
00001a  e02d              B        |L15.120|
                  |L15.28|
00001c  2101              MOVS     r1,#1                 ;190
00001e  4608              MOV      r0,r1                 ;190
000020  f7fffffe          BL       RCC_APB1PeriphResetCmd
000024  2100              MOVS     r1,#0                 ;191
000026  2001              MOVS     r0,#1                 ;191
000028  e026              B        |L15.120|
                  |L15.42|
;;;197      }
;;;198      else if (TIMx == TIM4)
00002a  4927              LDR      r1,|L15.200|
00002c  4288              CMP      r0,r1
00002e  d106              BNE      |L15.62|
;;;199      {
;;;200        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000030  2101              MOVS     r1,#1
000032  2004              MOVS     r0,#4
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;201        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
000038  2100              MOVS     r1,#0
00003a  2004              MOVS     r0,#4
00003c  e01c              B        |L15.120|
                  |L15.62|
;;;202      } 
;;;203      else if (TIMx == TIM5)
00003e  4923              LDR      r1,|L15.204|
000040  4288              CMP      r0,r1
000042  d106              BNE      |L15.82|
;;;204      {
;;;205        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000044  2101              MOVS     r1,#1
000046  2008              MOVS     r0,#8
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00004c  2100              MOVS     r1,#0
00004e  2008              MOVS     r0,#8
000050  e012              B        |L15.120|
                  |L15.82|
;;;207      } 
;;;208      else if (TIMx == TIM6)
000052  491f              LDR      r1,|L15.208|
000054  4288              CMP      r0,r1
000056  d106              BNE      |L15.102|
;;;209      {
;;;210        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2010              MOVS     r0,#0x10
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;211        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000060  2100              MOVS     r1,#0
000062  2010              MOVS     r0,#0x10
000064  e008              B        |L15.120|
                  |L15.102|
;;;212      } 
;;;213      else if (TIMx == TIM7)
000066  491b              LDR      r1,|L15.212|
000068  4288              CMP      r0,r1
00006a  d109              BNE      |L15.128|
;;;214      {
;;;215        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2020              MOVS     r0,#0x20
000070  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;216        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
000074  2100              MOVS     r1,#0
000076  2020              MOVS     r0,#0x20
                  |L15.120|
000078  e8bd4010          POP      {r4,lr}
00007c  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L15.128|
;;;217      } 
;;;218    
;;;219      else if (TIMx == TIM9)
000080  4915              LDR      r1,|L15.216|
000082  4288              CMP      r0,r1
000084  d106              BNE      |L15.148|
;;;220      {
;;;221        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
000086  2101              MOVS     r1,#1
000088  2004              MOVS     r0,#4
00008a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;222        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2004              MOVS     r0,#4
000092  e012              B        |L15.186|
                  |L15.148|
;;;223      } 
;;;224      else if (TIMx == TIM10)
000094  4911              LDR      r1,|L15.220|
000096  4288              CMP      r0,r1
000098  d106              BNE      |L15.168|
;;;225      {
;;;226        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2008              MOVS     r0,#8
00009e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;227        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2008              MOVS     r0,#8
0000a6  e008              B        |L15.186|
                  |L15.168|
;;;228      } 
;;;229      else
;;;230      {
;;;231        if (TIMx == TIM11)
0000a8  490d              LDR      r1,|L15.224|
0000aa  4288              CMP      r0,r1
0000ac  d109              BNE      |L15.194|
;;;232        {
;;;233          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000ae  2101              MOVS     r1,#1
0000b0  2010              MOVS     r0,#0x10
0000b2  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;234          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE); 
0000b6  2100              MOVS     r1,#0
0000b8  2010              MOVS     r0,#0x10
                  |L15.186|
0000ba  e8bd4010          POP      {r4,lr}
0000be  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L15.194|
;;;235        }  
;;;236      }
;;;237         
;;;238    }
0000c2  bd10              POP      {r4,pc}
;;;239    
                          ENDP

                  |L15.196|
                          DCD      0x40000400
                  |L15.200|
                          DCD      0x40000800
                  |L15.204|
                          DCD      0x40000c00
                  |L15.208|
                          DCD      0x40001000
                  |L15.212|
                          DCD      0x40001400
                  |L15.216|
                          DCD      0x40010800
                  |L15.220|
                          DCD      0x40010c00
                  |L15.224|
                          DCD      0x40011000

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;2275     */
;;;2276   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b510              PUSH     {r4,lr}
;;;2277                                uint16_t ExtTRGFilter)
;;;2278   {
000002  4604              MOV      r4,r0
;;;2279     uint16_t tmpsmcr = 0;
;;;2280     
;;;2281     /* Check the parameters */
;;;2282     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2283     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2284     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2285     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2286     
;;;2287     /* Configure the ETR Clock source */
;;;2288     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;2289     
;;;2290     /* Get the TIMx SMCR register value */
;;;2291     tmpsmcr = TIMx->SMCR;
000008  8920              LDRH     r0,[r4,#8]
;;;2292     /* Reset the SMS Bits */
;;;2293     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
;;;2294     /* Select the External clock mode1 */
;;;2295     tmpsmcr |= TIM_SlaveMode_External1;
;;;2296     /* Select the Trigger selection : ETRF */
;;;2297     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
;;;2298     tmpsmcr |= TIM_TS_ETRF;
00000a  f0400077          ORR      r0,r0,#0x77
;;;2299     /* Write to TIMx SMCR */
;;;2300     TIMx->SMCR = tmpsmcr;
00000e  8120              STRH     r0,[r4,#8]
;;;2301   }
000010  bd10              POP      {r4,pc}
;;;2302   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2319     */
;;;2320   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b510              PUSH     {r4,lr}
;;;2321                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2322   {
000002  4604              MOV      r4,r0
;;;2323     /* Check the parameters */
;;;2324     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2325     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2326     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2327     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2328     
;;;2329     /* Configure the ETR Clock source */
;;;2330     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;2331     /* Enable the External clock mode2 */
;;;2332     TIMx->SMCR |= TIM_SMCR_ECE;
000008  8920              LDRH     r0,[r4,#8]
00000a  f4404080          ORR      r0,r0,#0x4000
00000e  8120              STRH     r0,[r4,#8]
;;;2333   }
000010  bd10              POP      {r4,pc}
;;;2334   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;2504     */
;;;2505   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b530              PUSH     {r4,r5,lr}
;;;2506                      uint16_t ExtTRGFilter)
;;;2507   {
;;;2508     uint16_t tmpsmcr = 0;
;;;2509     
;;;2510     /* Check the parameters */
;;;2511     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2512     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2513     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2514     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2515     
;;;2516     tmpsmcr = TIMx->SMCR;
000002  8904              LDRH     r4,[r0,#8]
;;;2517     /* Reset the ETR Bits */
;;;2518     tmpsmcr &= SMCR_ETR_MASK;
;;;2519     /* Set the Prescaler, the Filter value and the Polarity */
;;;2520     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000004  f64f75ff          MOV      r5,#0xffff
000008  ea052303          AND      r3,r5,r3,LSL #8
00000c  4313              ORRS     r3,r3,r2
00000e  b2e4              UXTB     r4,r4                 ;2518
000010  430b              ORRS     r3,r3,r1
000012  4323              ORRS     r3,r3,r4
;;;2521     /* Write to TIMx SMCR */
;;;2522     TIMx->SMCR = tmpsmcr;
000014  8103              STRH     r3,[r0,#8]
;;;2523   }
000016  bd30              POP      {r4,r5,pc}
;;;2524   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;2559     */
;;;2560   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b570              PUSH     {r4-r6,lr}
;;;2561                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;2562   {
;;;2563     uint16_t tmpsmcr = 0;
;;;2564     uint16_t tmpccmr1 = 0;
;;;2565     uint16_t tmpccer = 0;
;;;2566       
;;;2567     /* Check the parameters */
;;;2568     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2569     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;2570     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;2571     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;2572     
;;;2573     /* Get the TIMx SMCR register value */
;;;2574     tmpsmcr = TIMx->SMCR;
000002  8905              LDRH     r5,[r0,#8]
;;;2575     /* Get the TIMx CCMR1 register value */
;;;2576     tmpccmr1 = TIMx->CCMR1;
000004  8b04              LDRH     r4,[r0,#0x18]
;;;2577     /* Get the TIMx CCER register value */
;;;2578     tmpccer = TIMx->CCER;
000006  8c06              LDRH     r6,[r0,#0x20]
;;;2579     /* Set the encoder Mode */
;;;2580     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000008  f0250507          BIC      r5,r5,#7
;;;2581     tmpsmcr |= TIM_EncoderMode;
00000c  430d              ORRS     r5,r5,r1
;;;2582     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2583     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
00000e  f64f41fc          MOV      r1,#0xfcfc
000012  400c              ANDS     r4,r4,r1
;;;2584     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000014  f2401101          MOV      r1,#0x101
000018  430c              ORRS     r4,r4,r1
;;;2585     /* Set the TI1 and the TI2 Polarities */
;;;2586     tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
;;;2587      tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00001a  f64f71ff          MOV      r1,#0xffff
00001e  ea011103          AND      r1,r1,r3,LSL #4
000022  f0260622          BIC      r6,r6,#0x22           ;2586
000026  4311              ORRS     r1,r1,r2
000028  4331              ORRS     r1,r1,r6
;;;2588     /* Write to TIMx SMCR */
;;;2589     TIMx->SMCR = tmpsmcr;
00002a  8105              STRH     r5,[r0,#8]
;;;2590     /* Write to TIMx CCMR1 */
;;;2591     TIMx->CCMR1 = tmpccmr1;
00002c  8304              STRH     r4,[r0,#0x18]
;;;2592     /* Write to TIMx CCER */
;;;2593     TIMx->CCER = tmpccer;
00002e  8401              STRH     r1,[r0,#0x20]
;;;2594   }
000030  bd70              POP      {r4-r6,pc}
;;;2595   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;958      */
;;;959    void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;960    {
;;;961      uint16_t tmpccmr1 = 0;
;;;962      /* Check the parameters */
;;;963      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;964      assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;965      tmpccmr1 = TIMx->CCMR1;
;;;966      /* Reset the OC1M Bits */
;;;967      tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000002  f0220270          BIC      r2,r2,#0x70
;;;968      /* Configure The Forced output Mode */
;;;969      tmpccmr1 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;970      /* Write to TIMx CCMR1 register */
;;;971      TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;972    }
00000a  4770              BX       lr
;;;973     
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;983      */
;;;984    void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;985    {
;;;986      uint16_t tmpccmr1 = 0;
;;;987      
;;;988      /* Check the parameters */
;;;989      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;990      assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;991      
;;;992      tmpccmr1 = TIMx->CCMR1;
;;;993      /* Reset the OC2M Bits */
;;;994      tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
;;;995      /* Configure The Forced output Mode */
;;;996      tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;994
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;997      /* Write to TIMx CCMR1 register */
;;;998      TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;999    }
000012  4770              BX       lr
;;;1000   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1009     */
;;;1010   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1011   {
;;;1012     uint16_t tmpccmr2 = 0;
;;;1013     
;;;1014     /* Check the parameters */
;;;1015     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1016     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1017     
;;;1018     tmpccmr2 = TIMx->CCMR2;
;;;1019     /* Reset the OC1M Bits */
;;;1020     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000002  f0220270          BIC      r2,r2,#0x70
;;;1021     /* Configure The Forced output Mode */
;;;1022     tmpccmr2 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1023     /* Write to TIMx CCMR2 register */
;;;1024     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1025   }
00000a  4770              BX       lr
;;;1026   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1035     */
;;;1036   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1037   {
;;;1038     uint16_t tmpccmr2 = 0;
;;;1039     /* Check the parameters */
;;;1040     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1041     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1042     
;;;1043     tmpccmr2 = TIMx->CCMR2;
;;;1044     /* Reset the OC2M Bits */
;;;1045     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
;;;1046     /* Configure The Forced output Mode */
;;;1047     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;1045
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1048     /* Write to TIMx CCMR2 register */
;;;1049     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1050   }
000012  4770              BX       lr
;;;1051   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;1918     */
;;;1919   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;1920   { 
;;;1921     /* Check the parameters */
;;;1922     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1923     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
;;;1924     /* Set the event sources */
;;;1925     TIMx->EGR = TIM_EventSource;
;;;1926   }
000002  4770              BX       lr
;;;1927   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;1705     */
;;;1706   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  6b40              LDR      r0,[r0,#0x34]
;;;1707   {
;;;1708     /* Check the parameters */
;;;1709     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1710     
;;;1711     /* Get the Capture 1 Register value */
;;;1712     return TIMx->CCR1;
;;;1713   }
000002  4770              BX       lr
;;;1714   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;1719     */
;;;1720   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  6b80              LDR      r0,[r0,#0x38]
;;;1721   {
;;;1722     /* Check the parameters */
;;;1723     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1724     
;;;1725     /* Get the Capture 2 Register value */
;;;1726     return TIMx->CCR2;
;;;1727   }
000002  4770              BX       lr
;;;1728   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;1733     */
;;;1734   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;1735   {
;;;1736     /* Check the parameters */
;;;1737     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;1738     
;;;1739     /* Get the Capture 3 Register value */
;;;1740     return TIMx->CCR3;
;;;1741   }
000002  4770              BX       lr
;;;1742   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;1747     */
;;;1748   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  6c00              LDR      r0,[r0,#0x40]
;;;1749   {
;;;1750     /* Check the parameters */
;;;1751     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1752     
;;;1753     /* Get the Capture 4 Register value */
;;;1754     return TIMx->CCR4;
;;;1755   }
000002  4770              BX       lr
;;;1756   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;386      */
;;;387    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  6a40              LDR      r0,[r0,#0x24]
;;;388    {
;;;389      /* Check the parameters */
;;;390      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;391      
;;;392      /* Get the Counter Register value */
;;;393      return TIMx->CNT;
;;;394    }
000002  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;1949     */
;;;1950   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;1951   { 
;;;1952     ITStatus bitstatus = RESET; 
000002  2000              MOVS     r0,#0
;;;1953      
;;;1954     /* Check the parameters */
;;;1955     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1956     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;1957     
;;;1958     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L30.12|
;;;1959     {
;;;1960       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L30.12|
;;;1961     }
;;;1962     else
;;;1963     {
;;;1964       bitstatus = RESET;
;;;1965     }
;;;1966     return bitstatus;
;;;1967   }
00000c  4770              BX       lr
;;;1968   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2019     */
;;;2020   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  4602              MOV      r2,r0
;;;2021   {
;;;2022     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2023     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2024     
;;;2025     /* Check the parameters */
;;;2026     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2027     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2028      
;;;2029     itstatus = TIMx->SR & TIM_IT;
000004  8a13              LDRH     r3,[r2,#0x10]
;;;2030     
;;;2031     itenable = TIMx->DIER & TIM_IT;
000006  8992              LDRH     r2,[r2,#0xc]
000008  420b              TST      r3,r1                 ;2029
00000a  ea020201          AND      r2,r2,r1
00000e  d002              BEQ      |L31.22|
;;;2032     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000010  2a00              CMP      r2,#0
000012  d000              BEQ      |L31.22|
;;;2033     {
;;;2034       bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L31.22|
;;;2035     }
;;;2036     else
;;;2037     {
;;;2038       bitstatus = RESET;
;;;2039     }
;;;2040     return bitstatus;
;;;2041   }
000016  4770              BX       lr
;;;2042   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;400      */
;;;401    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;402    {
;;;403      /* Check the parameters */
;;;404      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;405      
;;;406      /* Get the Prescaler Register value */
;;;407      return TIMx->PSC;
;;;408    }
000002  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1575     */
;;;1576   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1577   {
000004  460d              MOV      r5,r1
;;;1578     /* Check the parameters */
;;;1579     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1580     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1581     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1582     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1583     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1584     
;;;1585     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  880e              LDRH     r6,[r1,#0]
;;;1586     {
;;;1587       /* TI1 Configuration */
;;;1588       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000008  8849              LDRH     r1,[r1,#2]
00000a  88aa              LDRH     r2,[r5,#4]
00000c  892b              LDRH     r3,[r5,#8]
00000e  4604              MOV      r4,r0                 ;1577
000010  b316              CBZ      r6,|L33.88|
;;;1589                  TIM_ICInitStruct->TIM_ICSelection,
;;;1590                  TIM_ICInitStruct->TIM_ICFilter);
;;;1591       /* Set the Input Capture Prescaler value */
;;;1592       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1593     }
;;;1594     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000012  2e04              CMP      r6,#4
000014  d028              BEQ      |L33.104|
;;;1595     {
;;;1596       /* TI2 Configuration */
;;;1597       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1598       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1599                  TIM_ICInitStruct->TIM_ICSelection,
;;;1600                  TIM_ICInitStruct->TIM_ICFilter);
;;;1601       /* Set the Input Capture Prescaler value */
;;;1602       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1603     }
;;;1604     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000016  2e08              CMP      r6,#8
000018  8c26              LDRH     r6,[r4,#0x20]
00001a  f64f70ff          MOV      r0,#0xffff
00001e  d02b              BEQ      |L33.120|
000020  f4265680          BIC      r6,r6,#0x1000
000024  8426              STRH     r6,[r4,#0x20]
000026  8ba7              LDRH     r7,[r4,#0x1c]
000028  8c26              LDRH     r6,[r4,#0x20]
00002a  ea002202          AND      r2,r0,r2,LSL #8
00002e  ea003101          AND      r1,r0,r1,LSL #12
000032  f4274773          BIC      r7,r7,#0xf300
000036  433a              ORRS     r2,r2,r7
000038  ea003003          AND      r0,r0,r3,LSL #12
00003c  4310              ORRS     r0,r0,r2
00003e  f4264220          BIC      r2,r6,#0xa000
000042  430a              ORRS     r2,r2,r1
000044  f4425180          ORR      r1,r2,#0x1000
000048  83a0              STRH     r0,[r4,#0x1c]
00004a  8421              STRH     r1,[r4,#0x20]
;;;1605     {
;;;1606       /* TI3 Configuration */
;;;1607       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1608       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;1609                  TIM_ICInitStruct->TIM_ICSelection,
;;;1610                  TIM_ICInitStruct->TIM_ICFilter);
;;;1611       /* Set the Input Capture Prescaler value */
;;;1612       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1613     }
;;;1614     else
;;;1615     {
;;;1616       /* TI4 Configuration */
;;;1617       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1618       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1619                  TIM_ICInitStruct->TIM_ICSelection,
;;;1620                  TIM_ICInitStruct->TIM_ICFilter);
;;;1621       /* Set the Input Capture Prescaler value */
;;;1622       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004c  88e9              LDRH     r1,[r5,#6]
00004e  4620              MOV      r0,r4
000050  e8bd41f0          POP      {r4-r8,lr}
000054  f7ffbffe          B.W      TIM_SetIC4Prescaler
                  |L33.88|
000058  f7fffffe          BL       TI1_Config
00005c  88e9              LDRH     r1,[r5,#6]            ;1592
00005e  4620              MOV      r0,r4                 ;1592
000060  e8bd41f0          POP      {r4-r8,lr}            ;1592
000064  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L33.104|
000068  f7fffffe          BL       TI2_Config
00006c  88e9              LDRH     r1,[r5,#6]            ;1602
00006e  4620              MOV      r0,r4                 ;1602
000070  e8bd41f0          POP      {r4-r8,lr}            ;1602
000074  f7ffbffe          B.W      TIM_SetIC2Prescaler
                  |L33.120|
000078  f4267680          BIC      r6,r6,#0x100          ;1602
00007c  8426              STRH     r6,[r4,#0x20]         ;1602
00007e  8ba7              LDRH     r7,[r4,#0x1c]         ;1602
000080  8c26              LDRH     r6,[r4,#0x20]         ;1602
000082  ea002101          AND      r1,r0,r1,LSL #8       ;1602
000086  ea001003          AND      r0,r0,r3,LSL #4       ;1602
00008a  4310              ORRS     r0,r0,r2              ;1602
00008c  f02707f3          BIC      r7,r7,#0xf3           ;1602
000090  4338              ORRS     r0,r0,r7              ;1602
000092  f4266220          BIC      r2,r6,#0xa00          ;1602
000096  430a              ORRS     r2,r2,r1              ;1602
000098  f4427180          ORR      r1,r2,#0x100          ;1602
00009c  83a0              STRH     r0,[r4,#0x1c]         ;1602
00009e  8421              STRH     r1,[r4,#0x20]         ;1602
0000a0  88e9              LDRH     r1,[r5,#6]            ;1612
0000a2  4620              MOV      r0,r4                 ;1612
0000a4  e8bd41f0          POP      {r4-r8,lr}            ;1612
0000a8  f7ffbffe          B.W      TIM_SetIC3Prescaler
;;;1623     }
;;;1624   }
;;;1625   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;1631     */
;;;1632   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;1633   {
;;;1634     /* Set the default configuration */
;;;1635     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;1636     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;1637     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;1638     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;1639     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;1640   }
00000e  4770              BX       lr
;;;1641   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;1882     */
;;;1883   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1884   {  
;;;1885     /* Check the parameters */
;;;1886     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1887     assert_param(IS_TIM_IT(TIM_IT));
;;;1888     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1889     
;;;1890     if (NewState != DISABLE)
;;;1891     {
;;;1892       /* Enable the Interrupt sources */
;;;1893       TIMx->DIER |= TIM_IT;
;;;1894     }
;;;1895     else
;;;1896     {
;;;1897       /* Disable the Interrupt sources */
;;;1898       TIMx->DIER &= (uint16_t)~TIM_IT;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L35.10|
000006  430a              ORRS     r2,r2,r1              ;1893
000008  e000              B        |L35.12|
                  |L35.10|
00000a  438a              BICS     r2,r2,r1
                  |L35.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;1893
;;;1899     }
;;;1900   }
00000e  4770              BX       lr
;;;1901   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2208     */
;;;2209   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b500              PUSH     {lr}
;;;2210   {
000002  4603              MOV      r3,r0
;;;2211     /* Check the parameters */
;;;2212     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2213     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2214     /* Select the Internal Trigger */
;;;2215     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000004  f7fffffe          BL       TIM_SelectInputTrigger
;;;2216     /* Select the External clock mode1 */
;;;2217     TIMx->SMCR |= TIM_SlaveMode_External1;
000008  8918              LDRH     r0,[r3,#8]
00000a  f0400007          ORR      r0,r0,#7
00000e  8118              STRH     r0,[r3,#8]
;;;2218   }
000010  bd00              POP      {pc}
;;;2219   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;2189     */
;;;2190   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;2191   {
;;;2192     /* Check the parameters */
;;;2193     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2194     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2195     TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000002  f0210107          BIC      r1,r1,#7
000006  8101              STRH     r1,[r0,#8]
;;;2196   }
000008  4770              BX       lr
;;;2197   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1162     */
;;;1163   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1164   {
;;;1165     uint16_t tmpccmr1 = 0;
;;;1166     
;;;1167     /* Check the parameters */
;;;1168     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1169     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1170     
;;;1171     /* Get the TIMx CCMR1 register value */
;;;1172     tmpccmr1 = TIMx->CCMR1;
;;;1173     /* Reset the OC1FE Bit */
;;;1174     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000002  f0220204          BIC      r2,r2,#4
;;;1175     /* Enable or Disable the Output Compare Fast Bit */
;;;1176     tmpccmr1 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1177     /* Write to TIMx CCMR1 */
;;;1178     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1179   }
00000a  4770              BX       lr
;;;1180   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=1

                  TIM_OC1Init PROC
;;;613      */
;;;614    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b510              PUSH     {r4,lr}
;;;615    {
;;;616      uint16_t tmpccmrx = 0, tmpccer = 0;
;;;617       
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;620      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;621      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;622      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;623      /* Disable the Channel 1: Reset the CC1E Bit */
;;;624      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  8402              STRH     r2,[r0,#0x20]
;;;625      
;;;626      /* Get the TIMx CCER register value */
;;;627      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;628      
;;;629      /* Get the TIMx CCMR1 register value */
;;;630      tmpccmrx = TIMx->CCMR1;
00000c  8b03              LDRH     r3,[r0,#0x18]
;;;631        
;;;632      /* Reset the Output Compare Mode Bits */
;;;633      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
;;;634      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
;;;635      
;;;636      /* Select the Output Compare Mode */
;;;637      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00000e  880c              LDRH     r4,[r1,#0]
000010  f0230373          BIC      r3,r3,#0x73           ;634
000014  431c              ORRS     r4,r4,r3
;;;638      
;;;639      /* Reset the Output Polarity level */
;;;640      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
000016  f0220302          BIC      r3,r2,#2
;;;641      /* Set the Output Compare Polarity */
;;;642      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00001a  890a              LDRH     r2,[r1,#8]
00001c  431a              ORRS     r2,r2,r3
;;;643      
;;;644      /* Set the Output State */
;;;645      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00001e  884b              LDRH     r3,[r1,#2]
;;;646      
;;;647      /* Set the Capture Compare Register value */
;;;648      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000020  6849              LDR      r1,[r1,#4]
000022  4313              ORRS     r3,r3,r2              ;645
000024  6341              STR      r1,[r0,#0x34]
;;;649      
;;;650      /* Write to TIMx CCMR1 */
;;;651      TIMx->CCMR1 = tmpccmrx;
000026  8304              STRH     r4,[r0,#0x18]
;;;652      
;;;653      /* Write to TIMx CCER */
;;;654      TIMx->CCER = tmpccer;
000028  8403              STRH     r3,[r0,#0x20]
;;;655    }
00002a  bd10              POP      {r4,pc}
;;;656    
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1375     */
;;;1376   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1377   {
;;;1378     uint16_t tmpccer = 0;
;;;1379     
;;;1380     /* Check the parameters */
;;;1381     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1382     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1383     
;;;1384     tmpccer = TIMx->CCER;
;;;1385     /* Set or Reset the CC1P Bit */
;;;1386     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;1387     tmpccer |= TIM_OCPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1388     /* Write to TIMx CCER register */
;;;1389     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1390   }
00000a  4770              BX       lr
;;;1391   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1060     */
;;;1061   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1062   {
;;;1063     uint16_t tmpccmr1 = 0;
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1066     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1067     
;;;1068     tmpccmr1 = TIMx->CCMR1;
;;;1069     /* Reset the OC1PE Bit */
;;;1070     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1071     /* Enable or Disable the Output Compare Preload feature */
;;;1072     tmpccmr1 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1073     /* Write to TIMx CCMR1 register */
;;;1074     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1075   }
00000a  4770              BX       lr
;;;1076   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1189     */
;;;1190   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1191   {
;;;1192     uint16_t tmpccmr1 = 0;
;;;1193     
;;;1194     /* Check the parameters */
;;;1195     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1196     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1197     
;;;1198     /* Get the TIMx CCMR1 register value */
;;;1199     tmpccmr1 = TIMx->CCMR1;
;;;1200     /* Reset the OC2FE Bit */
;;;1201     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
;;;1202     /* Enable or Disable the Output Compare Fast Bit */
;;;1203     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1201
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1204     /* Write to TIMx CCMR1 */
;;;1205     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1206   }
000012  4770              BX       lr
;;;1207   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=1

                  TIM_OC2Init PROC
;;;665      */
;;;666    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;667    {
;;;668      uint16_t tmpccmrx = 0, tmpccer = 0;
;;;669       
;;;670      /* Check the parameters */
;;;671      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;672      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;673      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;674      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;675      /* Disable the Channel 2: Reset the CC2E Bit */
;;;676      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  8402              STRH     r2,[r0,#0x20]
;;;677      
;;;678      /* Get the TIMx CCER register value */  
;;;679      tmpccer = TIMx->CCER;
00000a  8c03              LDRH     r3,[r0,#0x20]
;;;680      
;;;681      /* Get the TIMx CCMR1 register value */
;;;682      tmpccmrx = TIMx->CCMR1;
00000c  8b02              LDRH     r2,[r0,#0x18]
;;;683        
;;;684      /* Reset the Output Compare Mode Bits */
;;;685      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
;;;686      
;;;687      /* Select the Output Compare Mode */
;;;688      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00000e  780c              LDRB     r4,[r1,#0]
000010  f42245e0          BIC      r5,r2,#0x7000         ;685
000014  f64f72ff          MOV      r2,#0xffff
000018  ea022404          AND      r4,r2,r4,LSL #8
00001c  432c              ORRS     r4,r4,r5
;;;689      
;;;690      /* Reset the Output Polarity level */
;;;691      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
00001e  f0230520          BIC      r5,r3,#0x20
;;;692      /* Set the Output Compare Polarity */
;;;693      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000022  890b              LDRH     r3,[r1,#8]
000024  ea021303          AND      r3,r2,r3,LSL #4
000028  432b              ORRS     r3,r3,r5
;;;694      
;;;695      /* Set the Output State */
;;;696      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
00002a  884d              LDRH     r5,[r1,#2]
;;;697      
;;;698      /* Set the Capture Compare Register value */
;;;699      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
00002c  6849              LDR      r1,[r1,#4]
00002e  ea021205          AND      r2,r2,r5,LSL #4       ;696
000032  431a              ORRS     r2,r2,r3              ;696
000034  6381              STR      r1,[r0,#0x38]
;;;700        
;;;701      /* Write to TIMx CCMR1 */
;;;702      TIMx->CCMR1 = tmpccmrx;
000036  8304              STRH     r4,[r0,#0x18]
;;;703      
;;;704      /* Write to TIMx CCER */
;;;705      TIMx->CCER = tmpccer;
000038  8402              STRH     r2,[r0,#0x20]
;;;706    }
00003a  bd30              POP      {r4,r5,pc}
;;;707    
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1400     */
;;;1401   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1402   {
;;;1403     uint16_t tmpccer = 0;
;;;1404     
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1407     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1408     
;;;1409     tmpccer = TIMx->CCER;
;;;1410     /* Set or Reset the CC2P Bit */
;;;1411     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
;;;1412     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000002  f64f73ff          MOV      r3,#0xffff
000006  f0220220          BIC      r2,r2,#0x20           ;1411
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1413     /* Write to TIMx CCER register */
;;;1414     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1415   }
000012  4770              BX       lr
;;;1416   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1085     */
;;;1086   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1087   {
;;;1088     uint16_t tmpccmr1 = 0;
;;;1089     /* Check the parameters */
;;;1090     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1091     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1092     
;;;1093     tmpccmr1 = TIMx->CCMR1;
;;;1094     /* Reset the OC2PE Bit */
;;;1095     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
;;;1096     /* Enable or Disable the Output Compare Preload feature */
;;;1097     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1095
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1098     /* Write to TIMx CCMR1 register */
;;;1099     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1100   }
000012  4770              BX       lr
;;;1101   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1216     */
;;;1217   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1218   {
;;;1219     uint16_t tmpccmr2 = 0;
;;;1220     
;;;1221     /* Check the parameters */
;;;1222     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1223     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1224     
;;;1225     /* Get the TIMx CCMR2 register value */
;;;1226     tmpccmr2 = TIMx->CCMR2;
;;;1227     /* Reset the OC3FE Bit */
;;;1228     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000002  f0220204          BIC      r2,r2,#4
;;;1229     /* Enable or Disable the Output Compare Fast Bit */
;;;1230     tmpccmr2 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1231     /* Write to TIMx CCMR2 */
;;;1232     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1233   }
00000a  4770              BX       lr
;;;1234   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=1

                  TIM_OC3Init PROC
;;;716      */
;;;717    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;718    {
;;;719      uint16_t tmpccmrx = 0, tmpccer = 0;
;;;720       
;;;721      /* Check the parameters */
;;;722      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;723      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;724      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;725      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;726    
;;;727      /* Disable the Channel 2: Reset the CC2E Bit */
;;;728      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  8402              STRH     r2,[r0,#0x20]
;;;729      
;;;730      /* Get the TIMx CCER register value */
;;;731      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;732      
;;;733      /* Get the TIMx CCMR2 register value */
;;;734      tmpccmrx = TIMx->CCMR2;
00000c  8b83              LDRH     r3,[r0,#0x1c]
;;;735        
;;;736      /* Reset the Output Compare Mode Bits */
;;;737      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
;;;738      
;;;739      /* Select the Output Compare Mode */
;;;740      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00000e  880c              LDRH     r4,[r1,#0]
000010  f0230370          BIC      r3,r3,#0x70           ;737
;;;741      
;;;742      /* Reset the Output Polarity level */
;;;743      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
000014  f4227500          BIC      r5,r2,#0x200
000018  431c              ORRS     r4,r4,r3              ;740
;;;744      /* Set the Output Compare Polarity */
;;;745      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00001a  7a0a              LDRB     r2,[r1,#8]
00001c  f64f73ff          MOV      r3,#0xffff
000020  ea032202          AND      r2,r3,r2,LSL #8
000024  432a              ORRS     r2,r2,r5
;;;746      
;;;747      /* Set the Output State */
;;;748      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000026  788d              LDRB     r5,[r1,#2]
;;;749      
;;;750      /* Set the Capture Compare Register value */
;;;751      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000028  6849              LDR      r1,[r1,#4]
00002a  ea032305          AND      r3,r3,r5,LSL #8       ;748
00002e  4313              ORRS     r3,r3,r2              ;748
000030  63c1              STR      r1,[r0,#0x3c]
;;;752      
;;;753      /* Write to TIMx CCMR2 */
;;;754      TIMx->CCMR2 = tmpccmrx;
000032  8384              STRH     r4,[r0,#0x1c]
;;;755      
;;;756      /* Write to TIMx CCER */
;;;757      TIMx->CCER = tmpccer;
000034  8403              STRH     r3,[r0,#0x20]
;;;758    }
000036  bd30              POP      {r4,r5,pc}
;;;759    
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1425     */
;;;1426   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1427   {
;;;1428     uint16_t tmpccer = 0;
;;;1429     
;;;1430     /* Check the parameters */
;;;1431     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1432     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1433     
;;;1434     tmpccer = TIMx->CCER;
;;;1435     /* Set or Reset the CC3P Bit */
;;;1436     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
;;;1437     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4227200          BIC      r2,r2,#0x200          ;1436
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1438     /* Write to TIMx CCER register */
;;;1439     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1440   }
000012  4770              BX       lr
;;;1441   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1110     */
;;;1111   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1112   {
;;;1113     uint16_t tmpccmr2 = 0;
;;;1114     
;;;1115     /* Check the parameters */
;;;1116     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1117     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1118     
;;;1119     tmpccmr2 = TIMx->CCMR2;
;;;1120     /* Reset the OC3PE Bit */
;;;1121     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1122     /* Enable or Disable the Output Compare Preload feature */
;;;1123     tmpccmr2 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1124     /* Write to TIMx CCMR2 register */
;;;1125     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1126   }
00000a  4770              BX       lr
;;;1127   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1243     */
;;;1244   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1245   {
;;;1246     uint16_t tmpccmr2 = 0;
;;;1247     
;;;1248     /* Check the parameters */
;;;1249     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1250     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1251     
;;;1252     /* Get the TIMx CCMR2 register value */
;;;1253     tmpccmr2 = TIMx->CCMR2;
;;;1254     /* Reset the OC4FE Bit */
;;;1255     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
;;;1256     /* Enable or Disable the Output Compare Fast Bit */
;;;1257     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1255
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1258     /* Write to TIMx CCMR2 */
;;;1259     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1260   }
000012  4770              BX       lr
;;;1261   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=1

                  TIM_OC4Init PROC
;;;768      */
;;;769    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;770    {
;;;771      uint16_t tmpccmrx = 0, tmpccer = 0;
;;;772       
;;;773      /* Check the parameters */
;;;774      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;775      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;776      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;777      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;778    
;;;779      /* Disable the Channel 2: Reset the CC4E Bit */
;;;780      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  8402              STRH     r2,[r0,#0x20]
;;;781      
;;;782      /* Get the TIMx CCER register value */
;;;783      tmpccer = TIMx->CCER;
00000a  8c03              LDRH     r3,[r0,#0x20]
;;;784      
;;;785      /* Get the TIMx CCMR2 register value */
;;;786      tmpccmrx = TIMx->CCMR2;
00000c  8b82              LDRH     r2,[r0,#0x1c]
;;;787        
;;;788      /* Reset the Output Compare Mode Bits */
;;;789      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
;;;790      
;;;791      /* Select the Output Compare Mode */
;;;792      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00000e  780c              LDRB     r4,[r1,#0]
000010  f42245e0          BIC      r5,r2,#0x7000         ;789
000014  f64f72ff          MOV      r2,#0xffff
000018  ea022404          AND      r4,r2,r4,LSL #8
00001c  432c              ORRS     r4,r4,r5
;;;793      
;;;794      /* Reset the Output Polarity level */
;;;795      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
00001e  f4235500          BIC      r5,r3,#0x2000
;;;796      /* Set the Output Compare Polarity */
;;;797      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000022  7a0b              LDRB     r3,[r1,#8]
000024  ea023303          AND      r3,r2,r3,LSL #12
000028  432b              ORRS     r3,r3,r5
;;;798      
;;;799      /* Set the Output State */
;;;800      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00002a  788d              LDRB     r5,[r1,#2]
;;;801      
;;;802      /* Set the Capture Compare Register value */
;;;803      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
00002c  6849              LDR      r1,[r1,#4]
00002e  ea023205          AND      r2,r2,r5,LSL #12      ;800
000032  431a              ORRS     r2,r2,r3              ;800
000034  6401              STR      r1,[r0,#0x40]
;;;804      
;;;805      /* Write to TIMx CCMR2 */  
;;;806      TIMx->CCMR2 = tmpccmrx;
000036  8384              STRH     r4,[r0,#0x1c]
;;;807      
;;;808      /* Write to TIMx CCER */
;;;809      TIMx->CCER = tmpccer;
000038  8402              STRH     r2,[r0,#0x20]
;;;810    }
00003a  bd30              POP      {r4,r5,pc}
;;;811    
                          ENDP


                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1450     */
;;;1451   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1452   {
;;;1453     uint16_t tmpccer = 0;
;;;1454     
;;;1455     /* Check the parameters */
;;;1456     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1457     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1458     
;;;1459     tmpccer = TIMx->CCER;
;;;1460     /* Set or Reset the CC4P Bit */
;;;1461     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
;;;1462     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4225200          BIC      r2,r2,#0x2000         ;1461
00000a  ea033101          AND      r1,r3,r1,LSL #12
00000e  4311              ORRS     r1,r1,r2
;;;1463     /* Write to TIMx CCER register */
;;;1464     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1465   }
000012  4770              BX       lr
;;;1466   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1136     */
;;;1137   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1138   {
;;;1139     uint16_t tmpccmr2 = 0;
;;;1140     
;;;1141     /* Check the parameters */
;;;1142     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1143     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1144     
;;;1145     tmpccmr2 = TIMx->CCMR2;
;;;1146     /* Reset the OC4PE Bit */
;;;1147     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
;;;1148     /* Enable or Disable the Output Compare Preload feature */
;;;1149     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1147
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1150     /* Write to TIMx CCMR2 register */
;;;1151     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1152   }
000012  4770              BX       lr
;;;1153   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;817      */
;;;818    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;819    {
;;;820      /* Set the default configuration */
;;;821      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;822      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;823      TIM_OCInitStruct->TIM_Pulse = 0x0000;
;;;824      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
000006  6041              STR      r1,[r0,#4]
000008  8101              STRH     r1,[r0,#8]
;;;825    }
00000a  4770              BX       lr
;;;826    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;1650     */
;;;1651   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1652   {
000004  460c              MOV      r4,r1
;;;1653     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000006  2600              MOVS     r6,#0
;;;1654     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;1655     /* Check the parameters */
;;;1656     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1657     /* Select the Opposite Input Polarity */
;;;1658     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000008  8849              LDRH     r1,[r1,#2]
00000a  4607              MOV      r7,r0                 ;1652
00000c  2501              MOVS     r5,#1                 ;1654
00000e  b901              CBNZ     r1,|L55.18|
;;;1659     {
;;;1660       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
                  |L55.18|
;;;1661     }
;;;1662     else
;;;1663     {
;;;1664       icoppositepolarity = TIM_ICPolarity_Rising;
;;;1665     }
;;;1666     /* Select the Opposite Input */
;;;1667     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000012  88a2              LDRH     r2,[r4,#4]
000014  2a01              CMP      r2,#1
000016  d100              BNE      |L55.26|
;;;1668     {
;;;1669       icoppositeselection = TIM_ICSelection_IndirectTI;
000018  2502              MOVS     r5,#2
                  |L55.26|
;;;1670     }
;;;1671     else
;;;1672     {
;;;1673       icoppositeselection = TIM_ICSelection_DirectTI;
;;;1674     }
;;;1675     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00001a  8820              LDRH     r0,[r4,#0]
;;;1676     {
;;;1677       /* TI1 Configuration */
;;;1678       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001c  8923              LDRH     r3,[r4,#8]
00001e  2800              CMP      r0,#0                 ;1675
;;;1679                  TIM_ICInitStruct->TIM_ICFilter);
;;;1680       /* Set the Input Capture Prescaler value */
;;;1681       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1682       /* TI2 Configuration */
;;;1683       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;1684       /* Set the Input Capture Prescaler value */
;;;1685       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1686     }
;;;1687     else
;;;1688     { 
;;;1689       /* TI2 Configuration */
;;;1690       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000020  4638              MOV      r0,r7
000022  d011              BEQ      |L55.72|
000024  f7fffffe          BL       TI2_Config
;;;1691                  TIM_ICInitStruct->TIM_ICFilter);
;;;1692       /* Set the Input Capture Prescaler value */
;;;1693       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000028  88e1              LDRH     r1,[r4,#6]
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;1694       /* TI1 Configuration */
;;;1695       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000030  8923              LDRH     r3,[r4,#8]
000032  462a              MOV      r2,r5
000034  4631              MOV      r1,r6
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       TI1_Config
;;;1696       /* Set the Input Capture Prescaler value */
;;;1697       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00003c  88e1              LDRH     r1,[r4,#6]
00003e  4638              MOV      r0,r7
000040  e8bd41f0          POP      {r4-r8,lr}
000044  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L55.72|
000048  f7fffffe          BL       TI1_Config
00004c  88e1              LDRH     r1,[r4,#6]            ;1681
00004e  4638              MOV      r0,r7                 ;1681
000050  f7fffffe          BL       TIM_SetIC1Prescaler
000054  8923              LDRH     r3,[r4,#8]            ;1683
000056  462a              MOV      r2,r5                 ;1683
000058  4631              MOV      r1,r6                 ;1683
00005a  4638              MOV      r0,r7                 ;1683
00005c  f7fffffe          BL       TI2_Config
000060  88e1              LDRH     r1,[r4,#6]            ;1685
000062  4638              MOV      r0,r7                 ;1685
000064  e8bd41f0          POP      {r4-r8,lr}            ;1685
000068  f7ffbffe          B.W      TIM_SetIC2Prescaler
;;;1698     }
;;;1699   }
;;;1700   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;310      */
;;;311    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;312    {
;;;313      /* Check the parameters */
;;;314      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;315      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;316      
;;;317      /* Set the Prescaler value */
;;;318      TIMx->PSC = Prescaler;
;;;319      /* Set or reset the UG Bit */
;;;320      TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;321    }
000004  4770              BX       lr
;;;322    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;2665     */
;;;2666   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint32_t TIM_Remap)
000000  f8302f50          LDRH     r2,[r0,#0x50]!
;;;2667   {
;;;2668     /* Check the parameters */
;;;2669     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2670     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;2671   
;;;2672     /* Set the Timer remapping configuration */
;;;2673     TIMx->OR &=  (uint16_t)(TIM_Remap >> 16);
000004  ea024211          AND      r2,r2,r1,LSR #16
000008  8002              STRH     r2,[r0,#0]
;;;2674     TIMx->OR |=  (uint16_t)TIM_Remap;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2675   }
000010  4770              BX       lr
;;;2676   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;2150     */
;;;2151   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2152   {
;;;2153     /* Check the parameters */
;;;2154     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2155     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2156     
;;;2157     if (NewState != DISABLE)
;;;2158     {
;;;2159       /* Set the CCDS Bit */
;;;2160       TIMx->CR2 |= TIM_CR2_CCDS;
;;;2161     }
;;;2162     else
;;;2163     {
;;;2164       /* Reset the CCDS Bit */
;;;2165       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L58.12|
000006  f0410108          ORR      r1,r1,#8              ;2160
00000a  e001              B        |L58.16|
                  |L58.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L58.16|
000010  8081              STRH     r1,[r0,#4]            ;2160
;;;2166     }
;;;2167   }
000012  4770              BX       lr
;;;2168   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2602     */
;;;2603   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2604   {
;;;2605     /* Check the parameters */
;;;2606     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2607     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2608     
;;;2609     if (NewState != DISABLE)
;;;2610     {
;;;2611       /* Set the TI1S Bit */
;;;2612       TIMx->CR2 |= TIM_CR2_TI1S;
;;;2613     }
;;;2614     else
;;;2615     {
;;;2616       /* Reset the TI1S Bit */
;;;2617       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L59.12|
000006  f0410180          ORR      r1,r1,#0x80           ;2612
00000a  e001              B        |L59.16|
                  |L59.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L59.16|
000010  8081              STRH     r1,[r0,#4]            ;2612
;;;2618     }
;;;2619   }
000012  4770              BX       lr
;;;2620   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;2385     */
;;;2386   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
;;;2387   {
;;;2388     uint16_t tmpsmcr = 0;
;;;2389   
;;;2390     /* Check the parameters */
;;;2391     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2392     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2393   
;;;2394     /* Get the TIMx SMCR register value */
;;;2395     tmpsmcr = TIMx->SMCR;
;;;2396     /* Reset the TS Bits */
;;;2397     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000002  f0220270          BIC      r2,r2,#0x70
;;;2398     /* Set the Input Trigger source */
;;;2399     tmpsmcr |= TIM_InputTriggerSource;
000006  430a              ORRS     r2,r2,r1
;;;2400     /* Write to TIMx SMCR */
;;;2401     TIMx->SMCR = tmpsmcr;
000008  8102              STRH     r2,[r0,#8]
;;;2402   }
00000a  4770              BX       lr
;;;2403   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2474     */
;;;2475   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2476   {
;;;2477     /* Check the parameters */
;;;2478     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2479     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2480     
;;;2481     /* Reset the MSM Bit */
;;;2482     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000002  f0220280          BIC      r2,r2,#0x80
000006  8102              STRH     r2,[r0,#8]
;;;2483     
;;;2484     /* Set or Reset the MSM Bit */
;;;2485     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2486   }
00000e  4770              BX       lr
;;;2487   
                          ENDP


                          AREA ||i.TIM_SelectOCREFClear||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCREFClear PROC
;;;1475     */
;;;1476   void TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear)
000000  8902              LDRH     r2,[r0,#8]
;;;1477   {
;;;1478     /* Check the parameters */
;;;1479     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1480     assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));
;;;1481   
;;;1482     /* Set the TIM_OCReferenceClear source */
;;;1483     TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
000002  f0220208          BIC      r2,r2,#8
000006  8102              STRH     r2,[r0,#8]
;;;1484     TIMx->SMCR |=  TIM_OCReferenceClear;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;1485   }
00000e  4770              BX       lr
;;;1486   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;850      */
;;;851    void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;852    {
;;;853      uint32_t tmp = 0;
;;;854      uint16_t tmp1 = 0;
;;;855    
;;;856      /* Check the parameters */
;;;857      assert_param(IS_TIM_LIST1_PERIPH(TIMx));  
;;;858      assert_param(IS_TIM_OCM(TIM_OCMode));
;;;859      
;;;860      tmp = (uint32_t) TIMx;
;;;861      tmp += CCMR_OFFSET;
;;;862    
;;;863      tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
000002  2401              MOVS     r4,#1
;;;864    
;;;865      /* Disable the Channel: Reset the CCxE Bit */
;;;866      TIMx->CCER &= (uint16_t) ~tmp1;
000004  8c05              LDRH     r5,[r0,#0x20]
000006  f1000318          ADD      r3,r0,#0x18           ;861
00000a  408c              LSLS     r4,r4,r1              ;863
00000c  43a5              BICS     r5,r5,r4
00000e  8405              STRH     r5,[r0,#0x20]
000010  b189              CBZ      r1,|L63.54|
;;;867    
;;;868      if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000012  2908              CMP      r1,#8
000014  d00f              BEQ      |L63.54|
000016  1f09              SUBS     r1,r1,#4
;;;869      {
;;;870        tmp += (TIM_Channel>>1);
;;;871    
;;;872        /* Reset the OCxM bits in the CCMRx register */
;;;873        *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
;;;874       
;;;875        /* Configure the OCxM bits in the CCMRx register */
;;;876        *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;877      }
;;;878      else
;;;879      {
;;;880        tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000018  f3c1004e          UBFX     r0,r1,#1,#15
00001c  4418              ADD      r0,r0,r3
;;;881    
;;;882        /* Reset the OCxM bits in the CCMRx register */
;;;883        *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
00001e  6801              LDR      r1,[r0,#0]
000020  f42141e0          BIC      r1,r1,#0x7000
000024  6001              STR      r1,[r0,#0]
;;;884        
;;;885        /* Configure the OCxM bits in the CCMRx register */
;;;886        *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000026  6801              LDR      r1,[r0,#0]
000028  f64f73ff          MOV      r3,#0xffff
00002c  ea032202          AND      r2,r3,r2,LSL #8
                  |L63.48|
000030  4311              ORRS     r1,r1,r2              ;876
000032  6001              STR      r1,[r0,#0]            ;876
;;;887      }
;;;888    }
000034  bd30              POP      {r4,r5,pc}
                  |L63.54|
000036  eb030051          ADD      r0,r3,r1,LSR #1       ;870
00003a  6801              LDR      r1,[r0,#0]            ;873
00003c  f0210170          BIC      r1,r1,#0x70           ;873
000040  6001              STR      r1,[r0,#0]            ;873
000042  6801              LDR      r1,[r0,#0]            ;876
000044  e7f4              B        |L63.48|
;;;889    
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;499      */
;;;500    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;501    {
;;;502      /* Check the parameters */
;;;503      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;504      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;505      
;;;506      /* Reset the OPM Bit */
;;;507      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;508      /* Configure the OPM Mode */
;;;509      TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;510    }
00000e  4770              BX       lr
;;;511    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2428     */
;;;2429   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2430   {
;;;2431     /* Check the parameters */
;;;2432     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2433     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2434   
;;;2435     /* Reset the MMS Bits */
;;;2436     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000002  f0220270          BIC      r2,r2,#0x70
000006  8082              STRH     r2,[r0,#4]
;;;2437     /* Select the TRGO source */
;;;2438     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;2439   }
00000e  4770              BX       lr
;;;2440   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2452     */
;;;2453   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2454   {
;;;2455     /* Check the parameters */
;;;2456     assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;2457     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2458     
;;;2459     /* Reset the SMS Bits */
;;;2460     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000002  f0220207          BIC      r2,r2,#7
000006  8102              STRH     r2,[r0,#8]
;;;2461     /* Select the Slave Mode */
;;;2462     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2463   }
00000e  4770              BX       lr
;;;2464   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;372      */
;;;373    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;374    {
;;;375      /* Check the parameters */
;;;376      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;377      
;;;378      /* Set the Autoreload Register value */
;;;379      TIMx->ARR = Autoreload;
;;;380    }
000002  4770              BX       lr
;;;381    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;521      */
;;;522    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;526      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;527      
;;;528      /* Reset the CKD Bits */
;;;529      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;530      /* Set the CKD value */
;;;531      TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;532    }
00000e  4770              BX       lr
;;;533    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;895      */
;;;896    void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;897    {
;;;898      /* Check the parameters */
;;;899      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;900      
;;;901      /* Set the Capture Compare1 Register value */
;;;902      TIMx->CCR1 = Compare1;
;;;903    }
000002  4770              BX       lr
;;;904    
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;910      */
;;;911    void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;912    {
;;;913      /* Check the parameters */
;;;914      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;915      
;;;916      /* Set the Capture Compare2 Register value */
;;;917      TIMx->CCR2 = Compare2;
;;;918    }
000002  4770              BX       lr
;;;919    
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;925      */
;;;926    void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;927    {
;;;928      /* Check the parameters */
;;;929      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;930      
;;;931      /* Set the Capture Compare3 Register value */
;;;932      TIMx->CCR3 = Compare3;
;;;933    }
000002  4770              BX       lr
;;;934    
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;940      */
;;;941    void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;942    {
;;;943      /* Check the parameters */
;;;944      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;945      
;;;946      /* Set the Capture Compare4 Register value */
;;;947      TIMx->CCR4 = Compare4;
;;;948    }
000002  4770              BX       lr
;;;949    
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;357      */
;;;358    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;359    {
;;;360      /* Check the parameters */
;;;361       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;362       
;;;363      /* Set the Counter Register value */
;;;364      TIMx->CNT = Counter;
;;;365    }
000002  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;1767     */
;;;1768   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1769   {
;;;1770     /* Check the parameters */
;;;1771     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1772     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1773     
;;;1774     /* Reset the IC1PSC Bits */
;;;1775     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8302              STRH     r2,[r0,#0x18]
;;;1776     /* Set the IC1PSC value */
;;;1777     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;1778   }
00000e  4770              BX       lr
;;;1779   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;1790     */
;;;1791   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1792   {
;;;1793     /* Check the parameters */
;;;1794     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1795     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1796     
;;;1797     /* Reset the IC2PSC Bits */
;;;1798     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8302              STRH     r2,[r0,#0x18]
;;;1799     /* Set the IC2PSC value */
;;;1800     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  430a              ORRS     r2,r2,r1
000014  8302              STRH     r2,[r0,#0x18]
;;;1801   }
000016  4770              BX       lr
;;;1802   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;1813     */
;;;1814   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1815   {
;;;1816     /* Check the parameters */
;;;1817     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1818     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1819     
;;;1820     /* Reset the IC3PSC Bits */
;;;1821     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8382              STRH     r2,[r0,#0x1c]
;;;1822     /* Set the IC3PSC value */
;;;1823     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  430a              ORRS     r2,r2,r1
00000c  8382              STRH     r2,[r0,#0x1c]
;;;1824   }
00000e  4770              BX       lr
;;;1825   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;1836     */
;;;1837   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1838   {  
;;;1839     /* Check the parameters */
;;;1840     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1841     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1842     
;;;1843     /* Reset the IC4PSC Bits */
;;;1844     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8382              STRH     r2,[r0,#0x1c]
;;;1845     /* Set the IC4PSC value */
;;;1846     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  430a              ORRS     r2,r2,r1
000014  8382              STRH     r2,[r0,#0x1c]
;;;1847   }
000016  4770              BX       lr
;;;1848   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2235     */
;;;2236   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b570              PUSH     {r4-r6,lr}
;;;2237                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2238   {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
;;;2239     /* Check the parameters */
;;;2240     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2241     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2242     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2243     
;;;2244     /* Configure the Timer Input Clock Source */
;;;2245     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000006  2960              CMP      r1,#0x60
000008  4604              MOV      r4,r0                 ;2238
;;;2246     {
;;;2247       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;2248     }
;;;2249     else
;;;2250     {
;;;2251       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00000a  f04f0201          MOV      r2,#1
00000e  4631              MOV      r1,r6
000010  d00a              BEQ      |L78.40|
000012  f7fffffe          BL       TI1_Config
                  |L78.22|
;;;2252     }
;;;2253     /* Select the Trigger source */
;;;2254     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000016  4629              MOV      r1,r5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SelectInputTrigger
;;;2255     /* Select the External clock mode1 */
;;;2256     TIMx->SMCR |= TIM_SlaveMode_External1;
00001e  8920              LDRH     r0,[r4,#8]
000020  f0400007          ORR      r0,r0,#7
000024  8120              STRH     r0,[r4,#8]
;;;2257   }
000026  bd70              POP      {r4-r6,pc}
                  |L78.40|
000028  f7fffffe          BL       TI2_Config
00002c  e7f3              B        |L78.22|
;;;2258   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;248      */
;;;249    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  8802              LDRH     r2,[r0,#0]
;;;250    {
;;;251      uint16_t tmpcr1 = 0;
;;;252    
;;;253      /* Check the parameters */
;;;254      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;255      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;256      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;257    
;;;258      tmpcr1 = TIMx->CR1;  
;;;259    
;;;260      if(((TIMx) == TIM2) || ((TIMx) == TIM3) || ((TIMx) == TIM4) || ((TIMx) == TIM5))
000002  f1b04f80          CMP      r0,#0x40000000
000006  d008              BEQ      |L79.26|
000008  4b0f              LDR      r3,|L79.72|
00000a  4298              CMP      r0,r3
00000c  d005              BEQ      |L79.26|
00000e  4b0f              LDR      r3,|L79.76|
000010  4298              CMP      r0,r3
000012  d002              BEQ      |L79.26|
000014  4b0e              LDR      r3,|L79.80|
000016  4298              CMP      r0,r3
000018  d103              BNE      |L79.34|
                  |L79.26|
;;;261      {											
;;;262        /* Select the Counter Mode */
;;;263        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
00001a  f0220370          BIC      r3,r2,#0x70
;;;264        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00001e  884a              LDRH     r2,[r1,#2]
000020  431a              ORRS     r2,r2,r3
                  |L79.34|
;;;265      }
;;;266     
;;;267      if(((TIMx) != TIM6) && ((TIMx) != TIM7))
000022  4b0c              LDR      r3,|L79.84|
000024  4298              CMP      r0,r3
000026  d006              BEQ      |L79.54|
000028  4b0b              LDR      r3,|L79.88|
00002a  4298              CMP      r0,r3
00002c  d003              BEQ      |L79.54|
;;;268      {
;;;269        /* Set the clock division */
;;;270        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
00002e  f4227340          BIC      r3,r2,#0x300
;;;271        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000032  890a              LDRH     r2,[r1,#8]
000034  431a              ORRS     r2,r2,r3
                  |L79.54|
;;;272      }
;;;273    
;;;274      TIMx->CR1 = tmpcr1;
000036  8002              STRH     r2,[r0,#0]
;;;275    
;;;276      /* Set the Autoreload value */
;;;277      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000038  684a              LDR      r2,[r1,#4]
00003a  62c2              STR      r2,[r0,#0x2c]
;;;278     
;;;279      /* Set the Prescaler value */
;;;280      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00003c  8809              LDRH     r1,[r1,#0]
00003e  8501              STRH     r1,[r0,#0x28]
;;;281        
;;;282      /* Generate an update event to reload the Prescaler value immediatly */
;;;283      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
000040  2101              MOVS     r1,#1
000042  8281              STRH     r1,[r0,#0x14]
;;;284    }
000044  4770              BX       lr
;;;285    
                          ENDP

000046  0000              DCW      0x0000
                  |L79.72|
                          DCD      0x40000400
                  |L79.76|
                          DCD      0x40000800
                  |L79.80|
                          DCD      0x40000c00
                  |L79.84|
                          DCD      0x40001000
                  |L79.88|
                          DCD      0x40001400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;291      */
;;;292    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;293    {
;;;294      /* Set the default configuration */
;;;295      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
;;;296      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000004  6041              STR      r1,[r0,#4]
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;297      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;298      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;299    }
00000e  4770              BX       lr
;;;300    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;416      */
;;;417    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422      
;;;423      if (NewState != DISABLE)
;;;424      {
;;;425        /* Set the Update Disable Bit */
;;;426        TIMx->CR1 |= TIM_CR1_UDIS;
;;;427      }
;;;428      else
;;;429      {
;;;430        /* Reset the Update Disable Bit */
;;;431        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L81.12|
000006  f0410102          ORR      r1,r1,#2              ;426
00000a  e001              B        |L81.16|
                  |L81.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L81.16|
000010  8001              STRH     r1,[r0,#0]            ;426
;;;432      }
;;;433    }
000012  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;445      */
;;;446    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;447    {
;;;448      /* Check the parameters */
;;;449      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;450      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;451      
;;;452      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;453      {
;;;454        /* Set the URS Bit */
;;;455        TIMx->CR1 |= TIM_CR1_URS;
;;;456      }
;;;457      else
;;;458      {
;;;459        /* Reset the URS Bit */
;;;460        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L82.12|
000006  f0410104          ORR      r1,r1,#4              ;455
00000a  e001              B        |L82.16|
                  |L82.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L82.16|
000010  8001              STRH     r1,[r0,#0]            ;455
;;;461      }
;;;462    }
000012  4770              BX       lr
;;;463    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_tim_c_c458916b____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_tim_c_c458916b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_tim_c_c458916b____REVSH|
#line 144
|__asm___15_stm32l1xx_tim_c_c458916b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
