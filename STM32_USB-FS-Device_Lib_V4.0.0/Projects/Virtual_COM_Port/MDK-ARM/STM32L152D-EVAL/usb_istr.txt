; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152d-eval\usb_istr.o --asm_dir=.\STM32L152D-EVAL\ --list_dir=.\STM32L152D-EVAL\ --depend=.\stm32l152d-eval\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152D_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DSTM32L1XX_HD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_HD -DUSE_STM32L152D_EVAL ..\src\usb_istr.c]
                          THUMB

                          AREA ||i.USB_Istr||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;76     *******************************************************************************/
;;;77     void USB_Istr(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;78     {
;;;79         uint32_t i=0;
;;;80      __IO uint32_t EP[8];
;;;81       
;;;82       wIstr = _GetISTR();
000004  4e4c              LDR      r6,|L1.312|
000006  b088              SUB      sp,sp,#0x20           ;78
000008  2400              MOVS     r4,#0                 ;79
00000a  6830              LDR      r0,[r6,#0]
00000c  4d4b              LDR      r5,|L1.316|
00000e  8068              STRH     r0,[r5,#2]
;;;83     
;;;84     #if (IMR_MSK & ISTR_SOF)
;;;85       if (wIstr & ISTR_SOF & wInterrupt_Mask)
000010  8868              LDRH     r0,[r5,#2]  ; wIstr
000012  4f4b              LDR      r7,|L1.320|
000014  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
000016  4008              ANDS     r0,r0,r1
000018  0580              LSLS     r0,r0,#22
00001a  d507              BPL      |L1.44|
;;;86       {
;;;87         _SetISTR((uint16_t)CLR_SOF);
00001c  f64f50ff          MOV      r0,#0xfdff
000020  6030              STR      r0,[r6,#0]
;;;88         bIntPackSOF++;
000022  7828              LDRB     r0,[r5,#0]  ; bIntPackSOF
000024  1c40              ADDS     r0,r0,#1
000026  7028              STRB     r0,[r5,#0]
;;;89     
;;;90     #ifdef SOF_CALLBACK
;;;91         SOF_Callback();
000028  f7fffffe          BL       SOF_Callback
                  |L1.44|
;;;92     #endif
;;;93       }
;;;94     #endif
;;;95       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/  
;;;96       
;;;97     #if (IMR_MSK & ISTR_CTR)
;;;98       if (wIstr & ISTR_CTR & wInterrupt_Mask)
00002c  8868              LDRH     r0,[r5,#2]  ; wIstr
00002e  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
000030  4008              ANDS     r0,r0,r1
000032  0400              LSLS     r0,r0,#16
000034  d501              BPL      |L1.58|
;;;99       {
;;;100        /* servicing of the endpoint correct transfer interrupt */
;;;101        /* clear of the CTR flag into the sub */
;;;102        CTR_LP();
000036  f7fffffe          BL       CTR_LP
                  |L1.58|
;;;103    #ifdef CTR_CALLBACK
;;;104        CTR_Callback();
;;;105    #endif
;;;106      }
;;;107    #endif
;;;108      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/  
;;;109    #if (IMR_MSK & ISTR_RESET)
;;;110      if (wIstr & ISTR_RESET & wInterrupt_Mask)
00003a  8868              LDRH     r0,[r5,#2]  ; wIstr
00003c  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
;;;111      {
;;;112        _SetISTR((uint16_t)CLR_RESET);
00003e  f64f38ff          MOV      r8,#0xfbff
000042  4008              ANDS     r0,r0,r1              ;110
000044  0540              LSLS     r0,r0,#21             ;110
000046  d504              BPL      |L1.82|
000048  f8c68000          STR      r8,[r6,#0]
;;;113        Device_Property.Reset();
00004c  483d              LDR      r0,|L1.324|
00004e  6840              LDR      r0,[r0,#4]  ; Device_Property
000050  4780              BLX      r0
                  |L1.82|
;;;114    #ifdef RESET_CALLBACK
;;;115        RESET_Callback();
;;;116    #endif
;;;117      }
;;;118    #endif
;;;119      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;120    #if (IMR_MSK & ISTR_DOVR)
;;;121      if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;122      {
;;;123        _SetISTR((uint16_t)CLR_DOVR);
;;;124    #ifdef DOVR_CALLBACK
;;;125        DOVR_Callback();
;;;126    #endif
;;;127      }
;;;128    #endif
;;;129      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;130    #if (IMR_MSK & ISTR_ERR)
;;;131      if (wIstr & ISTR_ERR & wInterrupt_Mask)
000052  8869              LDRH     r1,[r5,#2]  ; wIstr
000054  8838              LDRH     r0,[r7,#0]  ; wInterrupt_Mask
000056  4001              ANDS     r1,r1,r0
000058  0489              LSLS     r1,r1,#18
00005a  d502              BPL      |L1.98|
;;;132      {
;;;133        _SetISTR((uint16_t)CLR_ERR);
00005c  f64d71ff          MOV      r1,#0xdfff
000060  6031              STR      r1,[r6,#0]
                  |L1.98|
;;;134    #ifdef ERR_CALLBACK
;;;135        ERR_Callback();
;;;136    #endif
;;;137      }
;;;138    #endif
;;;139      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;140    #if (IMR_MSK & ISTR_WKUP)
;;;141      if (wIstr & ISTR_WKUP & wInterrupt_Mask)
000062  8869              LDRH     r1,[r5,#2]  ; wIstr
000064  4001              ANDS     r1,r1,r0
000066  04c8              LSLS     r0,r1,#19
000068  d505              BPL      |L1.118|
;;;142      {
;;;143        _SetISTR((uint16_t)CLR_WKUP);
00006a  f64e70ff          MOV      r0,#0xefff
00006e  6030              STR      r0,[r6,#0]
;;;144        Resume(RESUME_EXTERNAL);
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       Resume
                  |L1.118|
;;;145    #ifdef WKUP_CALLBACK
;;;146        WKUP_Callback();
;;;147    #endif
;;;148      }
;;;149    #endif
;;;150      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;151    #if (IMR_MSK & ISTR_SUSP)
;;;152      if (wIstr & ISTR_SUSP & wInterrupt_Mask)
000076  8868              LDRH     r0,[r5,#2]  ; wIstr
000078  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
00007a  4008              ANDS     r0,r0,r1
00007c  0500              LSLS     r0,r0,#20
00007e  d50b              BPL      |L1.152|
;;;153      {
;;;154    
;;;155        /* check if SUSPEND is possible */
;;;156        if (fSuspendEnabled)
000080  4831              LDR      r0,|L1.328|
000082  7800              LDRB     r0,[r0,#0]  ; fSuspendEnabled
000084  b110              CBZ      r0,|L1.140|
;;;157        {
;;;158          Suspend();
000086  f7fffffe          BL       Suspend
00008a  e002              B        |L1.146|
                  |L1.140|
;;;159        }
;;;160        else
;;;161        {
;;;162          /* if not possible then resume after xx ms */
;;;163          Resume(RESUME_LATER);
00008c  2002              MOVS     r0,#2
00008e  f7fffffe          BL       Resume
                  |L1.146|
;;;164        }
;;;165        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;166        _SetISTR((uint16_t)CLR_SUSP);
000092  f24f70ff          MOV      r0,#0xf7ff
000096  6030              STR      r0,[r6,#0]
                  |L1.152|
;;;167    #ifdef SUSP_CALLBACK
;;;168        SUSP_Callback();
;;;169    #endif
;;;170      }
;;;171    #endif
;;;172      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;173    
;;;174    #if (IMR_MSK & ISTR_ESOF)
;;;175      if (wIstr & ISTR_ESOF & wInterrupt_Mask)
000098  8868              LDRH     r0,[r5,#2]  ; wIstr
00009a  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
00009c  4008              ANDS     r0,r0,r1
00009e  05c0              LSLS     r0,r0,#23
0000a0  d546              BPL      |L1.304|
;;;176      {
;;;177        /* clear ESOF flag in ISTR */
;;;178        _SetISTR((uint16_t)CLR_ESOF);
0000a2  f64f60ff          MOV      r0,#0xfeff
0000a6  6030              STR      r0,[r6,#0]
;;;179        
;;;180        if ((_GetFNR()&FNR_RXDP)!=0)
0000a8  4823              LDR      r0,|L1.312|
0000aa  1d00              ADDS     r0,r0,#4
0000ac  6800              LDR      r0,[r0,#0]
0000ae  f04f0200          MOV      r2,#0
0000b2  0400              LSLS     r0,r0,#16
0000b4  d538              BPL      |L1.296|
;;;181        {
;;;182          /* increment ESOF counter */
;;;183          esof_counter ++;
0000b6  6868              LDR      r0,[r5,#4]  ; esof_counter
0000b8  1c40              ADDS     r0,r0,#1
0000ba  6068              STR      r0,[r5,#4]  ; esof_counter
;;;184          
;;;185          /* test if we enter in ESOF more than 3 times with FSUSP =0 and RXDP =1=>> possible missing SUSP flag*/
;;;186          if ((esof_counter >3)&&((_GetCNTR()&CNTR_FSUSP)==0))
0000bc  6868              LDR      r0,[r5,#4]  ; esof_counter
0000be  2803              CMP      r0,#3
0000c0  d933              BLS      |L1.298|
0000c2  481d              LDR      r0,|L1.312|
0000c4  1f00              SUBS     r0,r0,#4
0000c6  6801              LDR      r1,[r0,#0]
0000c8  0709              LSLS     r1,r1,#28
0000ca  d42e              BMI      |L1.298|
;;;187          {           
;;;188            /* this a sequence to apply a force RESET*/
;;;189          
;;;190            /*Store CNTR value */
;;;191            wCNTR = _GetCNTR(); 
0000cc  6801              LDR      r1,[r0,#0]
0000ce  b289              UXTH     r1,r1
0000d0  60a9              STR      r1,[r5,#8]  ; wCNTR
;;;192          
;;;193            /*Store endpoints registers status */
;;;194            for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
0000d2  491e              LDR      r1,|L1.332|
0000d4  ea4f030d          MOV.W    r3,sp
                  |L1.216|
0000d8  eb010784          ADD      r7,r1,r4,LSL #2
0000dc  f8d77c00          LDR      r7,[r7,#0xc00]
0000e0  b2bf              UXTH     r7,r7
0000e2  f8437024          STR      r7,[r3,r4,LSL #2]
0000e6  1c64              ADDS     r4,r4,#1
0000e8  2c08              CMP      r4,#8
0000ea  d3f5              BCC      |L1.216|
;;;195          
;;;196            /*apply FRES */
;;;197            wCNTR|=CNTR_FRES;
0000ec  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000ee  f0440401          ORR      r4,r4,#1
0000f2  60ac              STR      r4,[r5,#8]  ; wCNTR
;;;198            _SetCNTR(wCNTR);
0000f4  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000f6  b2a4              UXTH     r4,r4
0000f8  6004              STR      r4,[r0,#0]
;;;199     
;;;200            /*clear FRES*/
;;;201            wCNTR&=~CNTR_FRES;
0000fa  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000fc  f0240401          BIC      r4,r4,#1
000100  60ac              STR      r4,[r5,#8]  ; wCNTR
;;;202            _SetCNTR(wCNTR);
000102  68ac              LDR      r4,[r5,#8]  ; wCNTR
000104  b2a4              UXTH     r4,r4
000106  6004              STR      r4,[r0,#0]
                  |L1.264|
;;;203          
;;;204            /*poll for RESET flag in ISTR*/
;;;205            while((_GetISTR()&ISTR_RESET) == 0);
000108  6830              LDR      r0,[r6,#0]
00010a  0540              LSLS     r0,r0,#21
00010c  d5fc              BPL      |L1.264|
;;;206      
;;;207            /* clear RESET flag in ISTR */
;;;208            _SetISTR((uint16_t)CLR_RESET);
00010e  f8c68000          STR      r8,[r6,#0]
;;;209       
;;;210           /*restore Enpoints*/
;;;211            for (i=0;i<8;i++)
000112  2000              MOVS     r0,#0
                  |L1.276|
;;;212            _SetENDPOINT(i, EP[i]);
000114  f8534020          LDR      r4,[r3,r0,LSL #2]
000118  eb010680          ADD      r6,r1,r0,LSL #2
00011c  b2a4              UXTH     r4,r4
00011e  f8c64c00          STR      r4,[r6,#0xc00]
000122  1c40              ADDS     r0,r0,#1
000124  2808              CMP      r0,#8                 ;211
000126  d3f5              BCC      |L1.276|
                  |L1.296|
;;;213          
;;;214            esof_counter = 0;
000128  606a              STR      r2,[r5,#4]  ; esof_counter
                  |L1.298|
;;;215          }
;;;216        }
;;;217        else
;;;218        {
;;;219            esof_counter = 0;
;;;220        }
;;;221        
;;;222        /* resume handling timing is made with ESOFs */
;;;223        Resume(RESUME_ESOF); /* request without change of the machine state */
00012a  2007              MOVS     r0,#7
00012c  f7fffffe          BL       Resume
                  |L1.304|
;;;224    
;;;225    #ifdef ESOF_CALLBACK
;;;226        ESOF_Callback();
;;;227    #endif
;;;228      }
;;;229    #endif
;;;230    } /* USB_Istr */
000130  b008              ADD      sp,sp,#0x20
000132  e8bd81f0          POP      {r4-r8,pc}
;;;231    
                          ENDP

000136  0000              DCW      0x0000
                  |L1.312|
                          DCD      0x40005c44
                  |L1.316|
                          DCD      ||.data||
                  |L1.320|
                          DCD      wInterrupt_Mask
                  |L1.324|
                          DCD      Device_Property
                  |L1.328|
                          DCD      fSuspendEnabled
                  |L1.332|
                          DCD      0x40005000

                          AREA ||.data||, DATA, ALIGN=2

                  bIntPackSOF
000000  0000              DCB      0x00,0x00
                  wIstr
000002  0000              DCB      0x00,0x00
                  esof_counter
                          DCD      0x00000000
                  wCNTR
                          DCD      0x00000000

                          AREA ||area_number.5||, DATA, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.data||
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

                          AREA ||area_number.6||, DATA, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.data||
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      EP3_OUT_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_istr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_istr_c_e9471872____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REVSH|
#line 144
|__asm___10_usb_istr_c_e9471872____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
